use num_traits::Num;

/// Create a dimension type alias
///
/// This macro generates a public type alias for any dimension type. It creates
/// conve/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness. It prevents
/// dimensional errors like adding length to time at compile time.
///
/// # Type Parameters
/// - `V`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `system!` macro)
/// - `S`: The dimension scale defining the unit system (optional, defaults to `()`)
///
/// # Examples
/// ```rust
/// use num_units::quantity::Quantity;
/// use num_units::{length, time};
/// use num_units::{length as length_units, time as time_units};
/// use typenum::*;
///
/// // Create quantities with dimensional safety
/// let distance = length::Length::from::<length_units::Meter>(100.0);
/// let time_val = time::Time::from::<time_units::Second>(10.0);
///
/// // Automatic dimensional analysis - velocity = distance / time
/// let velocity = distance / time_val;
///
/// // Type safety prevents dimensional errors
/// // let invalid = distance + time_val; // âŒ Compile error!
///
/// // Display quantities with their dimensions
/// println!("Distance: {}", distance);  // Shows value with unit
/// println!("Velocity: {}", velocity);  // Shows value with derived unit
/// ```
#[macro_export]
macro_rules! quantity {
    ($name:ident, $dimension:ty, $scale_name:ty, $base_unit:ty) => {
        ::paste::paste! {
            mod [<$name:snake>] {
                use super::*;

                pub type Dimension = $dimension;
                pub type Scale = $scale_name;

                pub type $name<V> = $crate::quantity::Quantity<V, $dimension, $scale_name>;
            }

            // Generate BaseUnitOf implementation if base unit is specified
            impl $crate::quantity::BaseUnitOf<$dimension> for Scale {
                type BaseUnit = $base_unit;
            }
        }
    };
}

pub mod add;
// pub mod as_primitive;
// pub mod checked_add;
// pub mod checked_div;
// pub mod checked_mul;
// pub mod checked_neg;
// pub mod checked_rem;
// pub mod checked_sub;
pub mod const_one;
pub mod const_zero;
pub mod div;
pub mod float;
pub mod float_const;
// pub mod from_primitive;
pub mod mul;
pub mod mul_add;
pub mod mul_add_assign;
// pub mod neg;
// pub mod num_cast;
pub mod one;
pub mod pow;
pub mod rem;
// pub mod saturating_add;
// pub mod saturating_mul;
// pub mod saturating_sub;
pub mod signed;
pub mod sub;
// pub mod to_primitive;
// pub mod wrapping_add;
// pub mod wrapping_mul;
// pub mod wrapping_neg;
// pub mod wrapping_sub;
pub mod zero;

/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness.
///
/// # Type Parameters
/// - `V`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `system!` macro)
/// - `S`: The dimension scale defining the unit system (optional, defaults to ())
///
/// # Examples
/// ```rust
/// # use num_units::quantity::Quantity;
/// # use num_units::{ISQ, SiScale};
/// # use typenum::*;
///
/// let length = Quantity::<f64, ISQ<P1, Z0, Z0, Z0, Z0, Z0, Z0>, SiScale>::from_base(5.0);
/// let width = Quantity::<f64, ISQ<P1, Z0, Z0, Z0, Z0, Z0, Z0>, SiScale>::from_base(3.0);
/// let total_length = length + width; // Same dimensions - addition works
/// ```
#[derive(Debug, PartialEq, Eq)]
pub struct Quantity<V, D, S> {
    pub value: V,
    _dimension: core::marker::PhantomData<D>,
    _scale: core::marker::PhantomData<S>,
}

impl<V, D, S> Clone for Quantity<V, D, S>
where
    V: Clone,
{
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            _dimension: core::marker::PhantomData,
            _scale: core::marker::PhantomData,
        }
    }
}

impl<V, D, S> Copy for Quantity<V, D, S> where V: Copy {}

impl<V, D, S> Quantity<V, D, S>
where
    V: Num,
{
    /// Get the value of this quantity scaled to its base units
    pub fn base(&self) -> &V {
        &self.value
    }

    /// Consume the quantity and return the value scaled to its base units
    pub fn into_base(self) -> V {
        self.value
    }

    /// Create a quantity from a base value
    pub const fn from_base(value: V) -> Self {
        Self {
            value,
            _dimension: core::marker::PhantomData,
            _scale: core::marker::PhantomData,
        }
    }
}

// Generic implementations for any numeric type that supports unit conversions
impl<V, D, S> Quantity<V, D, S>
where
    V: num_traits::Num + Copy,
{
    /// Create a quantity from a value in a specific unit
    ///
    /// This method automatically infers the base unit from the dimension and scale,
    /// then converts from the specified unit to the base unit for storage.
    ///
    /// # Examples
    /// ```rust
    /// use num_units::length;
    ///
    /// // Create a length from kilometers - automatically converts to meters (base unit)
    /// let distance = length::Length::from::<num_units::length::Kilometer>(2.5);
    /// assert_eq!(*distance.base(), 2500.0); // Stored as 2500 meters
    /// ```
    pub fn from<U>(value: V) -> Self
    where
        U: crate::unit::Unit,
        S: BaseUnitOf<D>,
        S::BaseUnit: crate::unit::Unit + crate::unit::FromUnit<U, V>,
    {
        use crate::unit::FromUnit;
        // Convert FROM unit U TO BaseUnit
        let base_value = <S::BaseUnit as FromUnit<U, V>>::to_base(value);
        Self::from_base(base_value)
    }

    /// Create a quantity from a value in the base unit (no conversion)
    pub fn from_base_unit(value: V) -> Self
    where
        S: BaseUnitOf<D>,
        S::BaseUnit: crate::unit::Unit,
    {
        Self::from_base(value)
    }

    /// Get the value of this quantity in a specific unit
    ///
    /// This method automatically infers the base unit from the dimension and scale,
    /// then converts from the base unit to the specified unit.
    ///
    /// # Examples
    /// ```rust
    /// use num_units::length;
    ///
    /// let distance = length::Length::from_base(2500.0); // 2500 meters
    /// let km_value = distance.to::<num_units::length::Kilometer>();
    /// assert_eq!(km_value, 2.5);
    /// ```
    pub fn to<U>(&self) -> V
    where
        U: crate::unit::Unit,
        S: BaseUnitOf<D>,
        S::BaseUnit: crate::unit::Unit + crate::unit::FromUnit<U, V>,
    {
        // Convert FROM BaseUnit TO U using from_base
        <S::BaseUnit as crate::unit::FromUnit<U, V>>::from_base(self.value)
    }

    /// Get the value of this quantity in the base unit (no conversion)
    pub fn to_base_unit(&self) -> V
    where
        S: BaseUnitOf<D>,
        S::BaseUnit: crate::unit::Unit,
    {
        self.value
    }
}

/// Trait to map a scale and dimension to its base unit
/// This will be implemented by the system! macro for each dimension-scale combination
pub trait BaseUnitOf<D> {
    type BaseUnit: crate::unit::Unit;
}

// Unit-aware methods for f64 quantities
impl<D, S> Quantity<f64, D, S> {
    // Unit-specific methods are now generated by the unit! macro
}

// Display implementation
impl<V, D, S> core::fmt::Display for Quantity<V, D, S>
where
    V: core::fmt::Display,
    D: core::fmt::Display + Default,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{} [{}]", self.value, D::default())
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn test_quantity_creation() {
        // Use motion system dimensions
        let length = crate::length::Length::from_base(5.0);
        assert_eq!(*length.base(), 5.0);
    }

    #[test]
    fn test_quantity_macro() {
        // Test using motion system types directly
        let length = crate::length::Length::from_base(2.5);
        let area = crate::area::Area::from_base(9.8);

        assert_eq!(*length.base(), 2.5);
        assert_eq!(*area.base(), 9.8);
    }

    #[test]
    fn test_display() {
        let length = crate::length::Length::from_base(3.14159);
        // Test that the display trait is implemented
        // In no_std, we can't easily test format! but we can verify the trait exists
        let _: &dyn core::fmt::Display = &length;
    }

    #[test]
    fn test_motion_system_integration() {
        // Test basic motion quantities
        let length = crate::length::Length::from_base(10.0);
        let time = crate::time::Time::from_base(2.0);

        // Test dimensional analysis - velocity = length / time
        let velocity = length / time;
        assert_eq!(*velocity.base(), 5.0);

        // Test area calculation - area = length * length
        let area = length * length;
        assert_eq!(*area.base(), 100.0);

        // Test volume calculation - volume = area * length
        let volume = area * length;
        assert_eq!(*volume.base(), 1000.0);
    }

    #[test]
    fn test_generic_unit_conversion() {
        // Test creating a length quantity from kilometers
        let distance = crate::length::Length::from::<crate::isq::length::Kilometer>(2.5);
        assert_eq!(*distance.base(), 2500.0); // Should be 2500 meters

        // Test getting the value in different units
        let km_value = distance.to::<crate::isq::length::Kilometer>();
        assert_eq!(km_value, 2.5);

        // For base unit, use to_base_unit
        let m_value = distance.to_base_unit();
        assert_eq!(m_value, 2500.0);

        let cm_value = distance.to::<crate::isq::length::Centimeter>();
        assert_eq!(cm_value, 250000.0);

        // Test creating from centimeters
        let small_distance = crate::length::Length::from::<crate::isq::length::Centimeter>(150.0);
        assert_eq!(*small_distance.base(), 1.5); // Should be 1.5 meters

        // For base unit, use to_base_unit
        let m_from_cm = small_distance.to_base_unit();
        assert_eq!(m_from_cm, 1.5);

        // Test creating from base unit
        let base_distance = crate::length::Length::from_base_unit(100.0);
        assert_eq!(*base_distance.base(), 100.0);
    }

    #[test]
    fn test_improved_api_demo() {
        // Demonstrate the much cleaner API

        // Length conversions - no need to specify base unit!
        let distance = crate::length::Length::from::<crate::isq::length::Kilometer>(5.0);
        assert_eq!(*distance.base(), 5000.0); // 5000 meters

        let in_cm = distance.to::<crate::isq::length::Centimeter>();
        assert_eq!(in_cm, 500000.0); // 500,000 cm

        let in_mm = distance.to::<crate::isq::length::Millimeter>();
        assert_eq!(in_mm, 5000000.0); // 5,000,000 mm

        // TODO: Mass and time conversions need fixing in the conversion definitions
        // The conversion macros seem to have the wrong direction

        // The API is now much cleaner:
        // OLD: Length::from::<Kilometer, Meter>(value)
        // NEW: Length::from::<Kilometer>(value)

        // OLD: distance.to::<Centimeter, Meter>()
        // NEW: distance.to::<Centimeter>()

        // Base unit is automatically inferred from the dimension!
    }

    #[test]
    fn test_unit_conversion_debug() {
        use crate::isq::length::{Centimeter, Kilometer, Meter};
        use crate::unit::FromUnit;

        // Let's test different directions to understand the trait
        println!("=== Kilometer conversions ===");
        println!(
            "<Meter as FromUnit<Kilometer>>::to_base(2.5): {}",
            <Meter as FromUnit<Kilometer>>::to_base(2.5)
        );
        println!(
            "<Meter as FromUnit<Kilometer>>::from_base(2500.0): {}",
            <Meter as FromUnit<Kilometer>>::from_base(2500.0)
        );

        println!("=== Centimeter conversions ===");
        println!(
            "<Meter as FromUnit<Centimeter>>::to_base(250000.0): {}",
            <Meter as FromUnit<Centimeter>>::to_base(250000.0)
        );
        println!(
            "<Meter as FromUnit<Centimeter>>::from_base(2500.0): {}",
            <Meter as FromUnit<Centimeter>>::from_base(2500.0)
        );

        // Maybe I need to think differently:
        // What if "base" in the context of Meter means the quantity is stored in meters,
        // and to_base converts FROM the other unit TO meters (stored unit)
        // and from_base converts FROM meters TO the other unit

        // Test this hypothesis:
        // to_base should convert FROM kilometers TO meters: 2.5 km -> 2500 m
        // from_base should convert FROM meters TO kilometers: 2500 m -> 2.5 km

        // But I'm getting 0.0025 and 2500000, which are both wrong

        // Let me test the reverse direction too
        println!("=== Reverse direction ===");
        println!(
            "<Kilometer as FromUnit<Meter>>::to_base(2500.0): {}",
            <Kilometer as FromUnit<Meter>>::to_base(2500.0)
        );
        println!(
            "<Kilometer as FromUnit<Meter>>::from_base(2.5): {}",
            <Kilometer as FromUnit<Meter>>::from_base(2.5)
        );
    }
}
