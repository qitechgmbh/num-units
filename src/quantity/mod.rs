use num_traits::Num;

/// Create a dimension type alias
///
/// This macro generates a public type alias for any dimension type. It can work with
/// SI dimensions or any other dimension system.
///
/// # Parameters
/// - `$name`: The name of the dimension type alias to create
/// - `$dimension`: The complete dimension type (e.g., `Motion<P1, Z0, N1>`)
///
/// # Examples
/// ```rust
/// # use num_units::quantity;
/// # use num_units::motion;
///
/// // Use predefined motion system types
/// let length = motion::length::f64::Length::from_raw(5.0);
/// let width = motion::length::f64::Length::from_raw(3.0);
/// let total_length = length + width; // Same dimensions - addition works
///
/// let time = motion::time::f64::Time::from_raw(2.0);
/// let velocity = length / time; // Different dimensions - division works
/// ```
#[macro_export]
macro_rules! quantity {
    ($name:ident, $dimension:ty) => {
        ::paste::paste! {
            pub mod [<$name:snake>] {
                use super::*;

                pub type Dimension = $dimension;
                pub type [<$name Dimension>] = $dimension;

                pub mod r#i8 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i8, $dimension>;
                }

                pub mod r#u8 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u8, $dimension>;
                }

                pub mod r#i16 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i16, $dimension>;
                }

                pub mod r#u16 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u16, $dimension>;
                }

                pub mod r#i32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i32, $dimension>;
                }

                pub mod r#u32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u32, $dimension>;
                }

                pub mod r#i64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i64, $dimension>;
                }

                pub mod r#u64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u64, $dimension>;
                }

                pub mod r#i128 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i128, $dimension>;
                }

                pub mod r#u128 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u128, $dimension>;
                }

                pub mod r#f32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<f32, $dimension>;
                }

                pub mod r#f64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<f64, $dimension>;
                }

                pub type $name<V> = $crate::quantity::Quantity<V, $dimension>;
            }
        }
    };
}

pub mod add;
// pub mod as_primitive;
// pub mod checked_add;
// pub mod checked_div;
// pub mod checked_mul;
// pub mod checked_neg;
// pub mod checked_rem;
// pub mod checked_sub;
pub mod const_one;
pub mod const_zero;
pub mod div;
pub mod float;
pub mod float_const;
// pub mod from_primitive;
pub mod mul;
pub mod mul_add;
pub mod mul_add_assign;
// pub mod neg;
// pub mod num_cast;
pub mod one;
pub mod pow;
pub mod rem;
// pub mod saturating_add;
// pub mod saturating_mul;
// pub mod saturating_sub;
pub mod signed;
pub mod sub;
// pub mod to_primitive;
// pub mod wrapping_add;
// pub mod wrapping_mul;
// pub mod wrapping_neg;
// pub mod wrapping_sub;
pub mod zero;

/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness.
///
/// # Type Parameters
/// - `T`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `system!` macro)
///
/// # Examples
/// ```rust
/// # use num_units::quantity::Quantity;
/// # use num_units::motion;
/// # use typenum::*;
///
/// let length = Quantity::<f64, motion::Motion<P1, Z0>>::from_raw(5.0);
/// let width = Quantity::<f64, motion::Motion<P1, Z0>>::from_raw(3.0);
/// let total_length = length + width; // Same dimensions - addition works
/// ```
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Quantity<V, D> {
    pub value: V,
    _dimension: core::marker::PhantomData<D>,
}

impl<V, D> Quantity<V, D>
where
    V: Num,
{
    /// Get the numerical value of this quantity
    pub fn raw(&self) -> &V {
        &self.value
    }

    /// Get the numerical value of this quantity (consuming)
    pub fn into_raw(self) -> V {
        self.value
    }

    /// Create a quantity from a raw value
    pub const fn from_raw(value: V) -> Self {
        Self {
            value,
            _dimension: core::marker::PhantomData,
        }
    }
}

// Unit-aware methods for f64 quantities
impl<D> Quantity<f64, D> {
    // Unit-specific methods are now generated by the unit! macro
}

// Display implementation
impl<V, D> core::fmt::Display for Quantity<V, D>
where
    V: core::fmt::Display,
    D: core::fmt::Display + Default,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{} [{}]", self.value, D::default())
    }
}

#[cfg(test)]
mod tests {
    use crate::motion;

    #[test]
    fn test_quantity_creation() {
        // Use motion system dimensions
        let length = motion::length::f64::Length::from_raw(5.0);
        assert_eq!(*length.raw(), 5.0);

        let velocity = motion::velocity::i32::Velocity::from_raw(10);
        assert_eq!(*velocity.raw(), 10);
    }

    #[test]
    fn test_quantity_macro() {
        // Test using motion system types directly
        let length = motion::length::f64::Length::from_raw(2.5);
        let area = motion::area::f64::Area::from_raw(9.8);

        assert_eq!(*length.raw(), 2.5);
        assert_eq!(*area.raw(), 9.8);
    }

    #[test]
    fn test_display() {
        let length = motion::length::f64::Length::from_raw(3.14159);
        // Test that the display trait is implemented
        // In no_std, we can't easily test format! but we can verify the trait exists
        let _: &dyn core::fmt::Display = &length;
    }

    #[test]
    fn test_motion_system_integration() {
        // Test basic motion quantities
        let length = motion::length::f64::Length::from_raw(10.0);
        let time = motion::time::f64::Time::from_raw(2.0);

        // Test dimensional analysis - velocity = length / time
        let velocity = length / time;
        assert_eq!(*velocity.raw(), 5.0);

        // Test area calculation - area = length * length
        let area = length * length;
        assert_eq!(*area.raw(), 100.0);

        // Test volume calculation - volume = area * length
        let volume = area * length;
        assert_eq!(*volume.raw(), 1000.0);
    }
}
