use num_traits::Num;

/// Create a dimension type alias
///
/// This macro generates a public type alias for any dimension type. It can work with
/// SI dimensions or any other dimension system.
///
/// # Parameters
/// - `$name`: The name of the dimension type alias to create
/// - `$dimension`: The complete dimension type (e.g., `Motion<P1, Z0, N1>`)
///
/// # Examples
/// ```rust
/// # use num_units::quantity;
/// # use num_units::motion;
///
/// // Use predefined motion system types
/// let length = motion::length::f64::Length::from_raw(5.0);
/// let width = motion::length::f64::Length::from_raw(3.0);
/// let total_length = length + width; // Same dimensions - addition works
///
/// let time = motion::time::f64::Time::from_raw(2.0);
/// let velocity = length / time; // Different dimensions - division works
/// ```
#[macro_export]
macro_rules! quantity {
    ($name:ident, $dimension:ty) => {
        ::paste::paste! {
            pub mod [<$name:snake>] {
                use super::*;

                pub type Dimension = $dimension;
                pub type [<$name Dimension>] = $dimension;

                pub mod r#i8 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i8, $dimension>;
                }

                pub mod r#u8 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u8, $dimension>;
                }

                pub mod r#i16 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i16, $dimension>;
                }

                pub mod r#u16 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u16, $dimension>;
                }

                pub mod r#i32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i32, $dimension>;
                }

                pub mod r#u32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u32, $dimension>;
                }

                pub mod r#i64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i64, $dimension>;
                }

                pub mod r#u64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u64, $dimension>;
                }

                pub mod r#i128 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i128, $dimension>;
                }

                pub mod r#u128 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u128, $dimension>;
                }

                pub mod r#f32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<f32, $dimension>;
                }

                pub mod r#f64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<f64, $dimension>;
                }

                pub type $name<V> = $crate::quantity::Quantity<V, $dimension>;
            }
        }
    };
}

pub mod add;
// pub mod as_primitive;
// pub mod checked_add;
// pub mod checked_div;
// pub mod checked_mul;
// pub mod checked_neg;
// pub mod checked_rem;
// pub mod checked_sub;
pub mod const_one;
pub mod const_zero;
pub mod div;
pub mod float;
pub mod float_const;
// pub mod from_primitive;
pub mod mul;
pub mod mul_add;
pub mod mul_add_assign;
// pub mod neg;
// pub mod num_cast;
pub mod one;
pub mod pow;
pub mod rem;
// pub mod saturating_add;
// pub mod saturating_mul;
// pub mod saturating_sub;
pub mod signed;
pub mod sub;
// pub mod to_primitive;
// pub mod wrapping_add;
// pub mod wrapping_mul;
// pub mod wrapping_neg;
// pub mod wrapping_sub;
pub mod zero;

/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness.
///
/// # Type Parameters
/// - `T`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `system!` macro)
///
/// # Examples
/// ```rust
/// # use num_units::quantity::Quantity;
/// # use num_units::motion;
/// # use typenum::*;
///
/// let length = Quantity::<f64, motion::Motion<P1, Z0>>::from_raw(5.0);
/// let width = Quantity::<f64, motion::Motion<P1, Z0>>::from_raw(3.0);
/// let total_length = length + width; // Same dimensions - addition works
/// ```
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Quantity<V, D> {
    pub value: V,
    _dimension: core::marker::PhantomData<D>,
}

impl<V, D> Quantity<V, D>
where
    V: Num,
{
    /// Get the numerical value of this quantity
    pub fn raw(&self) -> &V {
        &self.value
    }

    /// Get the numerical value of this quantity (consuming)
    pub fn into_raw(self) -> V {
        self.value
    }

    /// Create a quantity from a raw value
    pub const fn from_raw(value: V) -> Self {
        Self {
            value,
            _dimension: core::marker::PhantomData,
        }
    }
}

// Unit-aware methods for f64 quantities
impl<D> Quantity<f64, D> {
    // Unit-specific methods are now generated by the unit! macro
}

// Display implementation
impl<V, D> core::fmt::Display for Quantity<V, D>
where
    V: core::fmt::Display,
    D: core::fmt::Display + Default,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{} [{}]", self.value, D::default())
    }
}

#[cfg(test)]
mod tests {
    use crate::motion;

    #[test]
    fn test_quantity_creation() {
        // Use motion system dimensions
        let length = motion::length::f64::Length::from_raw(5.0);
        assert_eq!(*length.raw(), 5.0);

        let velocity = motion::velocity::i32::Velocity::from_raw(10);
        assert_eq!(*velocity.raw(), 10);
    }

    #[test]
    fn test_quantity_macro() {
        // Test using motion system types directly
        let length = motion::length::f64::Length::from_raw(2.5);
        let area = motion::area::f64::Area::from_raw(9.8);

        assert_eq!(*length.raw(), 2.5);
        assert_eq!(*area.raw(), 9.8);
    }

    #[test]
    fn test_display() {
        let length = motion::length::f64::Length::from_raw(3.14159);
        // Test that the display trait is implemented
        // In no_std, we can't easily test format! but we can verify the trait exists
        let _: &dyn core::fmt::Display = &length;
    }

    #[test]
    fn test_motion_system_integration() {
        // Test basic motion quantities
        let length = motion::length::f64::Length::from_raw(10.0);
        let time = motion::time::f64::Time::from_raw(2.0);

        // Test dimensional analysis - velocity = length / time
        let velocity = length / time;
        assert_eq!(*velocity.raw(), 5.0);

        // Test area calculation - area = length * length
        let area = length * length;
        assert_eq!(*area.raw(), 100.0);

        // Test volume calculation - volume = area * length
        let volume = area * length;
        assert_eq!(*volume.raw(), 1000.0);
    }
}

/// Create a scaled quantity type alias for ScaledSystem
///
/// This macro generates quantity types that work with the ScaledSystem architecture,
/// which encodes both dimensions and base units at the type level.
///
/// # Parameters
/// - `$name`: The name of the quantity type to create
/// - `$scaled_system`: The ScaledSystem type (e.g., `LengthSI`, `AngleRadians`)
///
/// # Examples
/// ```rust
/// # use num_units::scaled_quantity;
/// # use num_units::scaled_system::*;
///
/// // Create a length quantity in SI system
/// scaled_quantity!(Length, LengthSI);
///
/// // Create an angle quantity with radians
/// scaled_quantity!(Angle, AngleRadians);
///
/// // Use the quantities
/// let length = Length::<f64>::from_raw(100.0);
/// let angle = Angle::<f64>::from_raw(1.57);
/// ```
#[macro_export]
macro_rules! scaled_quantity {
    ($name:ident, $scaled_system:ty) => {
        ::paste::paste! {
            pub mod [<$name:snake>] {
                use super::*;

                pub type Dimension = $scaled_system;

                pub mod r#i8 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<i8, $scaled_system>;
                }

                pub mod r#u8 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<u8, $scaled_system>;
                }

                pub mod r#i16 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<i16, $scaled_system>;
                }

                pub mod r#u16 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<u16, $scaled_system>;
                }

                pub mod r#i32 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<i32, $scaled_system>;
                }

                pub mod r#u32 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<u32, $scaled_system>;
                }

                pub mod r#i64 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<i64, $scaled_system>;
                }

                pub mod r#u64 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<u64, $scaled_system>;
                }

                pub mod r#i128 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<i128, $scaled_system>;
                }

                pub mod r#u128 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<u128, $scaled_system>;
                }

                pub mod r#f32 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<f32, $scaled_system>;
                }

                pub mod r#f64 {
                    use super::*;
                    pub type $name = $crate::quantity::ScaledQuantity<f64, $scaled_system>;
                }

                pub type $name<V> = $crate::quantity::ScaledQuantity<V, $scaled_system>;
            }
        }
    };
}

/// A physical quantity with ScaledSystem encoding
///
/// This struct combines a numerical value with a ScaledSystem that encodes
/// both dimensions and base units at the type level for maximum type safety.
///
/// # Type Parameters
/// - `V`: The numerical type (must implement `num-traits::Num`)
/// - `S`: The ScaledSystem type (encodes dimensions + base units)
///
/// # Examples
/// ```rust
/// # use num_units::quantity::ScaledQuantity;
/// # use num_units::scaled_system::*;
///
/// let length = ScaledQuantity::<f64, LengthSI>::from_raw(100.0);
/// let angle = ScaledQuantity::<f64, AngleRadians>::from_raw(1.57);
/// ```
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct ScaledQuantity<V, S: crate::scaled_system::ScaledSystemTrait> {
    pub value: V,
    _system: core::marker::PhantomData<S>,
}

impl<V, S> ScaledQuantity<V, S>
where
    V: Num,
    S: crate::scaled_system::ScaledSystemTrait,
{
    /// Get the numerical value of this quantity
    pub fn raw(&self) -> &V {
        &self.value
    }

    /// Get the numerical value of this quantity (consuming)
    pub fn into_raw(self) -> V {
        self.value
    }

    /// Create a quantity from a raw value
    pub const fn from_raw(value: V) -> Self {
        Self {
            value,
            _system: core::marker::PhantomData,
        }
    }

    /// Get the dimension exponent for a given dimension index
    pub const fn dimension_exponent(dim_index: usize) -> i32 {
        match dim_index {
            0 => S::LENGTH,
            1 => S::MASS,
            2 => S::TIME,
            3 => S::CURRENT,
            4 => S::TEMPERATURE,
            5 => S::AMOUNT,
            6 => S::LUMINOSITY,
            _ => 0,
        }
    }

    /// Check if this quantity is dimensionless
    pub const fn is_dimensionless() -> bool {
        S::IS_DIMENSIONLESS
    }
}

// Unit-aware methods for f64 scaled quantities
impl<S> ScaledQuantity<f64, S>
where
    S: crate::scaled_system::ScaledSystemTrait,
{
    // Unit-specific methods will be generated by the scaled_unit! macro
}

// Display implementation
impl<V, S> core::fmt::Display for ScaledQuantity<V, S>
where
    V: core::fmt::Display,
    S: crate::scaled_system::ScaledSystemTrait,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{} [ScaledSystem]", self.value)
    }
}
