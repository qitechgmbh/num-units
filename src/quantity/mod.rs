use num_traits::Num;

/// Create a dimension type alias
///
/// This macro generates a public type alias for any dimension type. It creates
/// conve/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness. It prevents
/// dimensional errors like adding length to time at compile time.
///
/// # Type Parameters
/// - `V`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `system!` macro)
/// - `S`: The dimension scale defining the unit system (optional, defaults to `()`)
///
/// # Examples
/// ```rust
/// use num_units::quantity::Quantity;
/// use num_units::si::{length, time};
/// use typenum::*;
///
/// // Create quantities with dimensional safety
/// let distance = length::f64::Length::from_base(100.0);
/// let time_val = time::f64::Time::from_base(10.0);
///
/// // Automatic dimensional analysis - velocity = distance / time
/// let velocity = distance / time_val;
///
/// // Type safety prevents dimensional errors
/// // let invalid = distance + time_val; // ❌ Compile error!
///
/// // Display quantities with their dimensions
/// println!("Distance: {}", distance);  // Shows value with unit
/// println!("Velocity: {}", velocity);  // Shows value with derived unit
/// ```
#[macro_export]
macro_rules! quantity {
    ($name:ident, $dimension:ty) => {
        quantity!($name, $dimension, ());
    };
    ($name:ident, $dimension:ty, $scale:ty) => {
        ::paste::paste! {
            pub mod [<$name:snake>] {
                use super::*;

                pub type Dimension = $dimension;
                pub type [<$name Dimension>] = $dimension;
                pub type Scale = $scale;
                pub type [<$name Scale>] = $scale;

                pub mod r#i8 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i8, $dimension, $scale>;
                }

                pub mod r#u8 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u8, $dimension, $scale>;
                }

                pub mod r#i16 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i16, $dimension, $scale>;
                }

                pub mod r#u16 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u16, $dimension, $scale>;
                }

                pub mod r#i32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i32, $dimension, $scale>;
                }

                pub mod r#u32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u32, $dimension, $scale>;
                }

                pub mod r#i64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i64, $dimension, $scale>;
                }

                pub mod r#u64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u64, $dimension, $scale>;
                }

                pub mod r#i128 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<i128, $dimension, $scale>;
                }

                pub mod r#u128 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<u128, $dimension, $scale>;
                }

                pub mod r#f32 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<f32, $dimension, $scale>;
                }

                pub mod r#f64 {
                    use super::*;
                    pub type $name = $crate::quantity::Quantity<f64, $dimension, $scale>;
                }

                pub type $name<V> = $crate::quantity::Quantity<V, $dimension, $scale>;
            }
        }
    };
}

pub mod add;
// pub mod as_primitive;
// pub mod checked_add;
// pub mod checked_div;
// pub mod checked_mul;
// pub mod checked_neg;
// pub mod checked_rem;
// pub mod checked_sub;
pub mod const_one;
pub mod const_zero;
pub mod div;
pub mod float;
pub mod float_const;
// pub mod from_primitive;
pub mod mul;
pub mod mul_add;
pub mod mul_add_assign;
// pub mod neg;
// pub mod num_cast;
pub mod one;
pub mod pow;
pub mod rem;
// pub mod saturating_add;
// pub mod saturating_mul;
// pub mod saturating_sub;
pub mod signed;
pub mod sub;
// pub mod to_primitive;
// pub mod wrapping_add;
// pub mod wrapping_mul;
// pub mod wrapping_neg;
// pub mod wrapping_sub;
pub mod zero;

/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness.
///
/// # Type Parameters
/// - `V`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `system!` macro)
/// - `S`: The dimension scale defining the unit system (optional, defaults to ())
///
/// # Examples
/// ```rust
/// # use num_units::quantity::Quantity;
/// # use num_units::motion;
/// # use typenum::*;
///
/// let length = Quantity::<f64, Motion<P1, Z0>>::from_raw(5.0);
/// let width = Quantity::<f64, Motion<P1, Z0>>::from_raw(3.0);
/// let total_length = length + width; // Same dimensions - addition works
/// ```
#[derive(Debug, PartialEq, Eq)]
pub struct Quantity<V, D, S> {
    pub value: V,
    _dimension: core::marker::PhantomData<D>,
    _scale: core::marker::PhantomData<S>,
}

impl<V, D, S> Clone for Quantity<V, D, S> where V: Clone {
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            _dimension: core::marker::PhantomData,
            _scale: core::marker::PhantomData,
        }
    }
}

impl<V, D, S> Copy for Quantity<V, D, S> where V: Copy {}

impl<V, D, S> Quantity<V, D, S>
where
    V: Num,
{
    /// Get the value of this quantity scaled to its base units
    pub fn base(&self) -> &V {
        &self.value
    }

    /// Consume the quantity and return the value scaled to its base units
    pub fn into_base(self) -> V {
        self.value
    }

    /// Create a quantity from a raw value
    pub const fn from_base(value: V) -> Self {
        Self {
            value,
            _dimension: core::marker::PhantomData,
            _scale: core::marker::PhantomData,
        }
    }
}

// Unit-aware methods for f64 quantities
impl<D, S> Quantity<f64, D, S> {
    // Unit-specific methods are now generated by the unit! macro
}

// Display implementation
impl<V, D, S> core::fmt::Display for Quantity<V, D, S>
where
    V: core::fmt::Display,
    D: core::fmt::Display + Default,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{} [{}]", self.value, D::default())
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn test_quantity_creation() {
        // Use motion system dimensions
        let length = crate::length::f64::Length::from_base(5.0);
        assert_eq!(*length.base(), 5.0);
    }

    #[test]
    fn test_quantity_macro() {
        // Test using motion system types directly
        let length = crate::length::f64::Length::from_base(2.5);
        let area = crate::area::f64::Area::from_base(9.8);

        assert_eq!(*length.base(), 2.5);
        assert_eq!(*area.base(), 9.8);
    }

    #[test]
    fn test_display() {
        let length = crate::length::f64::Length::from_base(3.14159);
        // Test that the display trait is implemented
        // In no_std, we can't easily test format! but we can verify the trait exists
        let _: &dyn core::fmt::Display = &length;
    }

    #[test]
    fn test_motion_system_integration() {
        // Test basic motion quantities
        let length = crate::length::f64::Length::from_base(10.0);
        let time = crate::time::f64::Time::from_base(2.0);

        // Test dimensional analysis - velocity = length / time
        let velocity = length / time;
        assert_eq!(*velocity.base(), 5.0);

        // Test area calculation - area = length * length
        let area = length * length;
        assert_eq!(*area.base(), 100.0);

        // Test volume calculation - volume = area * length
        let volume = area * length;
        assert_eq!(*volume.base(), 1000.0);
    }
}
