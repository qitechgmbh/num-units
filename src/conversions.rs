/// # Unit Conversions - Advanced Conversion System
///
/// This module provides a comprehensive trait-based conversion system that works
/// for both base units and derived units, using the FromUnit/IntoUnit
/// approach as the foundation.
///
/// ## Overview
///
/// The conversion system enables seamless conversion between different units
/// within the same dimension. It uses trait-based conversions that are
/// automatically generated by the unit definition macros.
///
/// ## Key Components
///
/// - **ConvertibleUnit Trait**: Extends Unit trait with conversion capabilities
/// - **FromUnit Trait**: Convert from any unit to its base unit
/// - **IntoUnit Trait**: Convert from base unit to any unit
/// - **Automatic Generation**: Conversion methods generated by macros
///
/// ## Macro Hierarchy
///
/// The conversion macros are organized in a hierarchical structure:
///
/// ### Top-Level Macros (User-facing)
/// - `convert!` - Main macro for floating-point conversions (delegates to `convert_float!`)
/// - `convert_linear!` - Simplified macro for linear conversions (y = ax + b)
/// - `convert_int!` - Macro for exact integer conversions
/// - `convert_int_linear!` - Simplified macro for integer linear conversions
/// - `convert_matrix!` - Generate all transitive conversions from a base unit
///
/// ### Type-Specific Generation Macros
/// - `convert_float!` - Generates f32 and f64 conversions
/// - `convert_signed!` - Generates all signed integer conversions (i8-i128)
/// - `convert_unsigned!` - Generates all unsigned integer conversions (u8-u128)
///
/// ### Individual Type Macros (Low-level)
/// - `convert_f32!`, `convert_f64!` - Floating-point implementations
/// - `convert_i8!` through `convert_i128!` - Signed integer implementations
/// - `convert_u8!` through `convert_u128!` - Unsigned integer implementations
///
/// ## Conversion Type Hierarchy
///
/// ```text
/// convert! (main entry point)
///     â””â”€â”€ convert_float!
///             â”œâ”€â”€ convert_f32!
///             â””â”€â”€ convert_f64!
///
/// convert_linear! (linear conversions)
///     â””â”€â”€ convert! â†’ convert_float!
///
/// convert_int! (integer conversions)
///     â””â”€â”€ Generates f32, f64, i32, i64 implementations directly
///
/// convert_matrix! (transitive conversions)
///     â””â”€â”€ convert_matrix_float!
///             â”œâ”€â”€ convert_matrix_generate_all_pairs_f32!
///             â””â”€â”€ convert_matrix_generate_all_pairs_f64!
/// ```
///
/// ## Usage Patterns
///
/// ### Basic Conversions
/// ```rust
/// use num_units::{convert, units};
///
/// // Define custom conversions
/// convert! {
///     Kilometer: |meter| meter / 1000.0;
///     Meter: |kilometer| kilometer * 1000.0;
/// }
/// ```
///
/// ### Linear Conversions
/// ```rust
/// use num_units::convert_linear;
///
/// // Simple scaling: 1 km = 1000 m
/// convert_linear! {
///     Kilometer => Meter: 1000.0;
/// }
///
/// // With offset: Â°C = K - 273.15
/// convert_linear! {
///     Celsius => Kelvin: 1.0, 273.15;
/// }
/// ```
///
/// ### Integer Conversions
/// ```rust
/// use num_units::convert_int;
///
/// // Exact integer conversions
/// convert_int! {
///     Millimeter: 1000;  // 1 meter = 1000 millimeters
///     Meter: 1;          // 1 meter = 1 meter (base)
/// }
/// ```
///
/// ### Matrix Conversions
/// ```rust
/// use num_units::{convert, convert_matrix};
///
/// // Define base conversions first
/// convert! {
///     Radian: |unitless| unitless * 2.0 * PI;
///     Unitless: |radian| radian / (2.0 * PI);
/// }
///
/// // Generate all transitive conversions
/// convert_matrix! {
///     Unitless => Revolution, Radian, Degree
/// }
/// // This generates: Revolution â†” Radian, Revolution â†” Degree, Radian â†” Degree
/// ```
///
/// ## Implementation Details
///
/// ### Conversion Flow
/// 1. User calls high-level macro (`convert!`, `convert_linear!`, etc.)
/// 2. Macro delegates to type-specific generators
/// 3. Type-specific macros create `FromUnit` trait implementations
/// 4. Runtime conversions use these trait implementations
///
/// ### Type Support
/// - **Floating-point**: f32, f64 - Full support with all conversion types
/// - **Signed integers**: i8, i16, i32, i64, i128 - Rounding applied for non-exact conversions
/// - **Unsigned integers**: u8, u16, u32, u64, u128 - Rounding applied for non-exact conversions
///
/// ### Precision Considerations
/// - Floating-point conversions maintain full precision
/// - Integer conversions use rounding when converting through floating-point
/// - For exact integer conversions, use `convert_int!` with integer factors
///
/// ## Best Practices
///
/// 1. **Use the simplest macro for your needs**:
///    - `convert_linear!` for simple scaling/offset conversions
///    - `convert_int!` for exact integer conversions
///    - `convert!` for complex custom conversions
///
/// 2. **Define a base unit for each dimension**:
///    - All other units convert to/from this base
///    - Use `convert_matrix!` to generate transitive conversions
///
/// 3. **Consider precision requirements**:
///    - Use integer macros when exact conversions are needed
///    - Be aware of rounding in integer conversions through floating-point
///
/// 4. **Organize conversions hierarchically**:
///    - Define base â†” derived conversions first
///    - Use matrix macro to generate derived â†” derived conversions

/// Trait for units that can be converted to/from base units
///
/// This trait extends the Unit trait with conversion capabilities
/// using the FromUnit/IntoUnit system.
pub trait ConvertibleUnit: crate::unit::Unit {
    /// The base unit for this unit's dimension
    type BaseUnit: crate::unit::Unit;

    /// Convert a value in this unit to its base unit
    fn to_base_unit<V>(value: V) -> V
    where
        V: num_traits::Num + Copy + From<f64> + num_traits::NumCast;

    /// Convert a value from this unit's base unit to this unit
    fn from_base_unit<V>(base_value: V) -> V
    where
        V: num_traits::Num + Copy + From<f64> + num_traits::NumCast;
}
/// Macro for establishing bidirectional conversion relationships between units (floating-point)
///
/// This macro creates conversion relationships between two units using floating-point
/// arithmetic. Use this for conversions that involve fractional factors. This is the
/// top-level macro that calls the hierarchical conversion macros.
///
/// # Syntax
/// ```ignore
/// use num_units::convert;
///
/// convert! {
///     TargetUnit: |source_param| conversion_expression;
///     SourceUnit: |target_param| reverse_conversion_expression;
/// }
/// ```
///
/// # Examples
/// ```ignore
/// use num_units::{convert, convert_float};
/// use num_units::prefix::KILO;
///
/// // Define conversion with floating-point factors
/// convert! {
///     Kilometer: |meter| meter / KILO;      // km = m / 1000.0
///     Meter: |kilometer| kilometer * KILO;  // m = km * 1000.0
/// }
/// ```
///
/// This automatically generates conversions for f32 and f64 types.
#[macro_export]
macro_rules! convert {
    ($($input:tt)*) => {
        $crate::convert_float! { $($input)* }
    };
}

/// Macro for generating linear conversion relationships (y = ax + b)
///
/// This macro simplifies the creation of linear unit conversions by automatically
/// generating the forward and reverse conversion expressions. It supports both
/// simple scaling (y = ax) and offset conversions (y = ax + b).
///
/// # Syntax
/// ```ignore
/// use num_units::convert_linear;
///
/// // Simple scaling (y = ax)
/// // DerivedUnit => BaseUnit: scale means 1 DerivedUnit = scale BaseUnits
/// convert_linear! {
///     DerivedUnit => BaseUnit: scale;
/// }
///
/// // With offset (y = ax + b)
/// // DerivedUnit => BaseUnit: scale, offset means DerivedUnit * scale + offset = BaseUnit
/// convert_linear! {
///     DerivedUnit => BaseUnit: scale, offset;
/// }
/// ```
///
/// # Generated Code
/// For `DerivedUnit => BaseUnit: a, b;`, this generates:
/// ```ignore
/// convert! {
///     DerivedUnit: |base| (base - b) / a;  // DerivedUnit = (BaseUnit - offset) / scale
///     BaseUnit: |derived| derived * a + b; // BaseUnit = DerivedUnit * scale + offset
/// }
/// ```
///
/// # Examples
/// ```ignore
/// use num_units::convert_linear;
/// use num_units::prefix::KILO;
///
/// // Simple scaling: 1 km = 1000 m (kilometer is derived, meter is base)
/// convert_linear! {
///     Kilometer => Meter: KILO;
/// }
/// // Generates:
/// // convert! {
/// //     Kilometer: |meter| meter / KILO;
/// //     Meter: |kilometer| kilometer * KILO;
/// // }
///
/// // With offset: Â°C + 273.15 = K (Celsius is derived, Kelvin is base)
/// convert_linear! {
///     Celsius => Kelvin: 1.0, 273.15;
/// }
/// // Generates:
/// // convert! {
/// //     Celsius: |kelvin| (kelvin - 273.15) / 1.0;
/// //     Kelvin: |celsius| celsius * 1.0 + 273.15;
/// // }
/// ```
#[macro_export]
macro_rules! convert_linear {
    // Pattern with both a and b (y = ax + b)
    // DerivedUnit => BaseUnit: scale, offset means:
    // DerivedUnit * scale + offset = BaseUnit
    // So: DerivedUnit = (BaseUnit - offset) / scale
    //     BaseUnit = DerivedUnit * scale + offset
    ($derived:ident => $base:ident: $a:expr, $b:expr;) => {
        $crate::convert! {
            $derived: |val| (val - ($b)) / ($a);
            $base: |val| val * ($a) + ($b);
        }
    };

    // Pattern with only a (y = ax)
    // DerivedUnit => BaseUnit: scale means 1 DerivedUnit = scale BaseUnits
    // E.g., Kilometer => Meter: 1000 means 1 km = 1000 m
    // So: DerivedUnit = BaseUnit / scale
    //     BaseUnit = DerivedUnit * scale
    ($derived:ident => $base:ident: $a:expr;) => {
        $crate::convert! {
            $derived: |val| val / ($a);
            $base: |val| val * ($a);
        }
    };

    // Multiple conversions
    ($($derived:ident => $base:ident: $($params:expr),+;)+) => {
        $(
            $crate::convert_linear! {
                $derived => $base: $($params),+;
            }
        )+
    };
}

/// Macro for generating integer linear conversion relationships
///
/// This is the integer version of `convert_linear!` which generates
/// `convert_int!` code for exact integer conversions. Use this when
/// both the scaling factor and offset (if any) are integers.
///
/// # Examples
/// ```ignore
/// use num_units::convert_int_linear;
///
/// // Simple integer scaling: 1 km = 1000 m (kilometer is derived, meter is base)
/// convert_int_linear! {
///     Kilometer => Meter: 1000;
/// }
/// // Generates:
/// // convert_int! {
/// //     Kilometer: 1;
/// //     Meter: 1000;
/// // }
/// ```
#[macro_export]
macro_rules! convert_int_linear {
    // Pattern with only scaling factor (integers use numerator/denominator pattern)
    // DerivedUnit => BaseUnit: scale means DerivedUnit * 1 = BaseUnit * scale
    ($derived:ident => $base:ident: $scale:expr;) => {
        $crate::convert_int! {
            $derived: 1;
            $base: $scale;
        }
    };

    // Multiple conversions
    ($($derived:ident => $base:ident: $scale:expr;)+) => {
        $(
            $crate::convert_int_linear! {
                $derived => $base: $scale;
            }
        )+
    };
}

// ===== HIERARCHICAL CONVERSION MACROS =====

/// Macro for specific integer type conversions (i8)
#[macro_export]
macro_rules! convert_i8 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (i8 version)
        impl $crate::unit::FromUnit<$unit2, i8> for $unit1 {
            fn to_base(value: i8) -> i8 {
                let $param2 = value as f64;
                ($expr1).round() as i8  // Use expr1 to convert FROM $unit2 TO base ($unit1)
            }

            fn from_base(base_value: i8) -> i8 {
                let $param1 = base_value as f64;
                ($expr2).round() as i8  // Use expr2 to convert FROM base ($unit1) TO $unit2
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i8 version)
        impl $crate::unit::FromUnit<$unit1, i8> for $unit2 {
            fn to_base(value: i8) -> i8 {
                let $param1 = value as f64;
                ($expr2).round() as i8  // Use expr2 to convert FROM $unit1 TO base ($unit2)
            }

            fn from_base(base_value: i8) -> i8 {
                let $param2 = base_value as f64;
                ($expr1).round() as i8  // Use expr1 to convert FROM base ($unit2) TO $unit1
            }
        }

        convert_i8! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i16)
#[macro_export]
macro_rules! convert_i16 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (i16 version)
        impl $crate::unit::FromUnit<$unit2, i16> for $unit1 {
            fn to_base(value: i16) -> i16 {
                let $param2 = value as f64;
                ($expr1).round() as i16
            }

            fn from_base(base_value: i16) -> i16 {
                let $param1 = base_value as f64;
                ($expr2).round() as i16
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i16 version)
        impl $crate::unit::FromUnit<$unit1, i16> for $unit2 {
            fn to_base(value: i16) -> i16 {
                let $param1 = value as f64;
                ($expr2).round() as i16
            }

            fn from_base(base_value: i16) -> i16 {
                let $param2 = base_value as f64;
                ($expr1).round() as i16
            }
        }

        convert_i16! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i32)
#[macro_export]
macro_rules! convert_i32 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (i32 version)
        impl $crate::unit::FromUnit<$unit2, i32> for $unit1 {
            fn to_base(value: i32) -> i32 {
                let $param2 = value as f64;
                ($expr1).round() as i32
            }

            fn from_base(base_value: i32) -> i32 {
                let $param1 = base_value as f64;
                ($expr2).round() as i32
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i32 version)
        impl $crate::unit::FromUnit<$unit1, i32> for $unit2 {
            fn to_base(value: i32) -> i32 {
                let $param1 = value as f64;
                ($expr2).round() as i32
            }

            fn from_base(base_value: i32) -> i32 {
                let $param2 = base_value as f64;
                ($expr1).round() as i32
            }
        }

        convert_i32! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i64)
#[macro_export]
macro_rules! convert_i64 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (i64 version)
        impl $crate::unit::FromUnit<$unit2, i64> for $unit1 {
            fn to_base(value: i64) -> i64 {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: i64) -> i64 {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i64 version)
        impl $crate::unit::FromUnit<$unit1, i64> for $unit2 {
            fn to_base(value: i64) -> i64 {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: i64) -> i64 {
                let $param2 = base_value;
                $expr1
            }
        }

        convert_i64! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i128)
#[macro_export]
macro_rules! convert_i128 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (i128 version)
        impl $crate::unit::FromUnit<$unit2, i128> for $unit1 {
            fn to_base(value: i128) -> i128 {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: i128) -> i128 {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i128 version)
        impl $crate::unit::FromUnit<$unit1, i128> for $unit2 {
            fn to_base(value: i128) -> i128 {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: i128) -> i128 {
                let $param2 = base_value;
                $expr1
            }
        }

        convert_i128! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u8)
#[macro_export]
macro_rules! convert_u8 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (u8 version)
        impl $crate::unit::FromUnit<$unit2, u8> for $unit1 {
            fn to_base(value: u8) -> u8 {
                let $param2 = value as f64;
                ($expr1).round() as u8
            }

            fn from_base(base_value: u8) -> u8 {
                let $param1 = base_value as f64;
                ($expr2).round() as u8
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (u8 version)
        impl $crate::unit::FromUnit<$unit1, u8> for $unit2 {
            fn to_base(value: u8) -> u8 {
                let $param1 = value as f64;
                ($expr2).round() as u8
            }

            fn from_base(base_value: u8) -> u8 {
                let $param2 = base_value as f64;
                ($expr1).round() as u8
            }
        }

        convert_u8! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u16)
#[macro_export]
macro_rules! convert_u16 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (u16 version)
        impl $crate::unit::FromUnit<$unit2, u16> for $unit1 {
            fn to_base(value: u16) -> u16 {
                let $param2 = value as f64;
                ($expr1).round() as u16
            }

            fn from_base(base_value: u16) -> u16 {
                let $param1 = base_value as f64;
                ($expr2).round() as u16
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (u16 version)
        impl $crate::unit::FromUnit<$unit1, u16> for $unit2 {
            fn to_base(value: u16) -> u16 {
                let $param1 = value as f64;
                ($expr2).round() as u16
            }

            fn from_base(base_value: u16) -> u16 {
                let $param2 = base_value as f64;
                ($expr1).round() as u16
            }
        }

        convert_u16! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u32)
#[macro_export]
macro_rules! convert_u32 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (u32 version)
        impl $crate::unit::FromUnit<$unit2, u32> for $unit1 {
            fn to_base(value: u32) -> u32 {
                let $param2 = value as f64;
                ($expr1).round() as u32
            }

            fn from_base(base_value: u32) -> u32 {
                let $param1 = base_value as f64;
                ($expr2).round() as u32
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (u32 version)
        impl $crate::unit::FromUnit<$unit1, u32> for $unit2 {
            fn to_base(value: u32) -> u32 {
                let $param1 = value as f64;
                ($expr2).round() as u32
            }

            fn from_base(base_value: u32) -> u32 {
                let $param2 = base_value as f64;
                ($expr1).round() as u32
            }
        }

        convert_u32! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u64)
#[macro_export]
macro_rules! convert_u64 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (u64 version)
        impl $crate::unit::FromUnit<$unit2, u64> for $unit1 {
            fn to_base(value: u64) -> u64 {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: u64) -> u64 {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (u64 version)
        impl $crate::unit::FromUnit<$unit1, u64> for $unit2 {
            fn to_base(value: u64) -> u64 {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: u64) -> u64 {
                let $param2 = base_value;
                $expr1
            }
        }

        convert_u64! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u128)
#[macro_export]
macro_rules! convert_u128 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (u128 version)
        impl $crate::unit::FromUnit<$unit2, u128> for $unit1 {
            fn to_base(value: u128) -> u128 {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: u128) -> u128 {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (u128 version)
        impl $crate::unit::FromUnit<$unit1, u128> for $unit2 {
            fn to_base(value: u128) -> u128 {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: u128) -> u128 {
                let $param2 = base_value;
                $expr1
            }
        }

        convert_u128! { $($rest)* }
    };
    () => {};
}

/// Macro for floating-point type conversions (f32)
#[macro_export]
macro_rules! convert_f32 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (f32 version)
        impl $crate::unit::FromUnit<$unit2, f32> for $unit1 {
            fn to_base(value: f32) -> f32 {
                let $param2 = value as f64;
                ($expr1) as f32
            }

            fn from_base(base_value: f32) -> f32 {
                let $param1 = base_value as f64;
                ($expr2) as f32
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (f32 version)
        impl $crate::unit::FromUnit<$unit1, f32> for $unit2 {
            fn to_base(value: f32) -> f32 {
                let $param1 = value as f64;
                ($expr2) as f32
            }

            fn from_base(base_value: f32) -> f32 {
                let $param2 = base_value as f64;
                ($expr1) as f32
            }
        }

        convert_f32! { $($rest)* }
    };
    () => {};
}

/// Macro for floating-point type conversions (f64)
#[macro_export]
macro_rules! convert_f64 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (f64 generic version)
        impl $crate::unit::FromUnit<$unit2, f64> for $unit1 {
            fn to_base(value: f64) -> f64 {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: f64) -> f64 {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (f64 generic version)
        impl $crate::unit::FromUnit<$unit1, f64> for $unit2 {
            fn to_base(value: f64) -> f64 {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: f64) -> f64 {
                let $param2 = base_value;
                $expr1
            }
        }

        convert_f64! { $($rest)* }
    };
    () => {};
}

/// Macro for all signed integer type conversions
#[macro_export]
macro_rules! convert_signed {
    ($($input:tt)*) => {
        $crate::convert_i8! { $($input)* }
        $crate::convert_i16! { $($input)* }
        $crate::convert_i32! { $($input)* }
        $crate::convert_i64! { $($input)* }
        $crate::convert_i128! { $($input)* }
    };
}

/// Macro for all unsigned integer type conversions
#[macro_export]
macro_rules! convert_unsigned {
    ($($input:tt)*) => {
        $crate::convert_u8! { $($input)* }
        $crate::convert_u16! { $($input)* }
        $crate::convert_u32! { $($input)* }
        $crate::convert_u64! { $($input)* }
        $crate::convert_u128! { $($input)* }
    };
}

/// Macro for all floating-point type conversions
#[macro_export]
macro_rules! convert_float {
    ($($input:tt)*) => {
        $crate::convert_f32! { $($input)* }
        $crate::convert_f64! { $($input)* }
    };
}

/// Macro for establishing bidirectional conversion relationships between units (integer)
///
/// This macro creates conversion relationships between two units using integer
/// arithmetic for exact conversions. Use this for conversions with exact integer factors.
///
/// # Syntax
/// ```ignore
/// use num_units::{units, convert_int};
///
/// // First define the units
/// units! {
///     TargetUnit: "tu", "target unit";
///     SourceUnit: "su", "source unit";
/// }
///
/// // Then define conversions (factors are relative to base)
/// convert_int! {
///     TargetUnit: 1;    // 1 base = 1 target
///     SourceUnit: 10;   // 1 base = 10 source
/// }
/// ```
///
/// # Examples
/// ```ignore
/// use num_units::{units, convert_int};
///
/// // First define the units
/// units! {
///     Millimeter: "mm", "millimeter";
///     Meter: "m", "meter";
/// }
///
/// // Define conversion with exact integer factors
/// convert_int! {
///     Millimeter: 1000;  // 1 meter = 1000 millimeters
///     Meter: 1;          // 1 meter = 1 meter (base unit)
/// }
/// ```
///
/// This generates both integer and floating-point implementations, with integer
/// implementations using exact arithmetic when possible.
#[macro_export]
macro_rules! convert_int {
    // Process pairs of units with integer conversion factors
    ($unit1:ident: $factor1:expr; $unit2:ident: $factor2:expr; $($rest:tt)*) => {
        // Forward conversion: $unit2 -> $unit1 (f64 version)
        impl $crate::unit::FromUnit<$unit2, f64> for $unit1 {
            fn to_base(value: f64) -> f64 {
                value * ($factor2 as f64) / ($factor1 as f64)
            }

            fn from_base(base_value: f64) -> f64 {
                base_value * ($factor1 as f64) / ($factor2 as f64)
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (f64 version)
        impl $crate::unit::FromUnit<$unit1, f64> for $unit2 {
            fn to_base(value: f64) -> f64 {
                value * ($factor1 as f64) / ($factor2 as f64)
            }

            fn from_base(base_value: f64) -> f64 {
                base_value * ($factor2 as f64) / ($factor1 as f64)
            }
        }

        // Forward conversion: $unit2 -> $unit1 (f32 version)
        impl $crate::unit::FromUnit<$unit2, f32> for $unit1 {
            fn to_base(value: f32) -> f32 {
                value * ($factor2 as f32) / ($factor1 as f32)
            }

            fn from_base(base_value: f32) -> f32 {
                base_value * ($factor1 as f32) / ($factor2 as f32)
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (f32 version)
        impl $crate::unit::FromUnit<$unit1, f32> for $unit2 {
            fn to_base(value: f32) -> f32 {
                value * ($factor1 as f32) / ($factor2 as f32)
            }

            fn from_base(base_value: f32) -> f32 {
                base_value * ($factor2 as f32) / ($factor1 as f32)
            }
        }

        // Forward conversion: $unit2 -> $unit1 (i32 version)
        impl $crate::unit::FromUnit<$unit2, i32> for $unit1 {
            fn to_base(value: i32) -> i32 {
                // Use integer arithmetic when possible
                if $factor2 % $factor1 == 0 {
                    value * ($factor2 / $factor1) as i32
                } else {
                    ((value as i64) * ($factor2 as i64) / ($factor1 as i64)) as i32
                }
            }

            fn from_base(base_value: i32) -> i32 {
                if $factor1 % $factor2 == 0 {
                    base_value * ($factor1 / $factor2) as i32
                } else {
                    ((base_value as i64) * ($factor1 as i64) / ($factor2 as i64)) as i32
                }
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i32 version)
        impl $crate::unit::FromUnit<$unit1, i32> for $unit2 {
            fn to_base(value: i32) -> i32 {
                if $factor1 % $factor2 == 0 {
                    value * ($factor1 / $factor2) as i32
                } else {
                    ((value as i64) * ($factor1 as i64) / ($factor2 as i64)) as i32
                }
            }

            fn from_base(base_value: i32) -> i32 {
                if $factor2 % $factor1 == 0 {
                    base_value * ($factor2 / $factor1) as i32
                } else {
                    ((base_value as i64) * ($factor2 as i64) / ($factor1 as i64)) as i32
                }
            }
        }

        // Forward conversion: $unit2 -> $unit1 (i64 version)
        impl $crate::unit::FromUnit<$unit2, i64> for $unit1 {
            fn to_base(value: i64) -> i64 {
                value * ($factor2 as i64) / ($factor1 as i64)
            }

            fn from_base(base_value: i64) -> i64 {
                base_value * ($factor1 as i64) / ($factor2 as i64)
            }
        }

        // Reverse conversion: $unit1 -> $unit2 (i64 version)
        impl $crate::unit::FromUnit<$unit1, i64> for $unit2 {
            fn to_base(value: i64) -> i64 {
                value * ($factor1 as i64) / ($factor2 as i64)
            }

            fn from_base(base_value: i64) -> i64 {
                base_value * ($factor2 as i64) / ($factor1 as i64)
            }
        }

        // Process remaining conversions recursively
        convert_int! { $($rest)* }
    };

    // Base case: no more conversions to process
    () => {};
}

// ðŸŽ©âœ¨ CONVERSION MATRIX MAGIC âœ¨ðŸŽ©
// Define conversions from one base unit to all others, then generate all combinations!

/// Generate a single bidirectional transitive conversion pair for i8
#[macro_export]
macro_rules! convert_matrix_generate_pair_i8 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - i8 version)
        impl $crate::unit::FromUnit<$from, i8> for $to {
            fn to_base(value: i8) -> i8 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, i8>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, i8>>::to_base(base_value)
            }

            fn from_base(base_value: i8) -> i8 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, i8>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, i8>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - i8 version)
        impl $crate::unit::FromUnit<$to, i8> for $from {
            fn to_base(value: i8) -> i8 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, i8>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, i8>>::to_base(base_value)
            }

            fn from_base(base_value: i8) -> i8 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, i8>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, i8>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for i16
#[macro_export]
macro_rules! convert_matrix_generate_pair_i16 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - i16 version)
        impl $crate::unit::FromUnit<$from, i16> for $to {
            fn to_base(value: i16) -> i16 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, i16>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, i16>>::to_base(base_value)
            }

            fn from_base(base_value: i16) -> i16 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, i16>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, i16>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - i16 version)
        impl $crate::unit::FromUnit<$to, i16> for $from {
            fn to_base(value: i16) -> i16 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, i16>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, i16>>::to_base(base_value)
            }

            fn from_base(base_value: i16) -> i16 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, i16>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, i16>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for i32
#[macro_export]
macro_rules! convert_matrix_generate_pair_i32 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - i32 version)
        impl $crate::unit::FromUnit<$from, i32> for $to {
            fn to_base(value: i32) -> i32 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, i32>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, i32>>::to_base(base_value)
            }

            fn from_base(base_value: i32) -> i32 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, i32>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, i32>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - i32 version)
        impl $crate::unit::FromUnit<$to, i32> for $from {
            fn to_base(value: i32) -> i32 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, i32>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, i32>>::to_base(base_value)
            }

            fn from_base(base_value: i32) -> i32 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, i32>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, i32>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for i64
#[macro_export]
macro_rules! convert_matrix_generate_pair_i64 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - i64 version)
        impl $crate::unit::FromUnit<$from, i64> for $to {
            fn to_base(value: i64) -> i64 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, i64>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, i64>>::to_base(base_value)
            }

            fn from_base(base_value: i64) -> i64 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, i64>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, i64>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - i64 version)
        impl $crate::unit::FromUnit<$to, i64> for $from {
            fn to_base(value: i64) -> i64 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, i64>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, i64>>::to_base(base_value)
            }

            fn from_base(base_value: i64) -> i64 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, i64>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, i64>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for i128
#[macro_export]
macro_rules! convert_matrix_generate_pair_i128 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - i128 version)
        impl $crate::unit::FromUnit<$from, i128> for $to {
            fn to_base(value: i128) -> i128 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, i128>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, i128>>::to_base(base_value)
            }

            fn from_base(base_value: i128) -> i128 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, i128>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, i128>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - i128 version)
        impl $crate::unit::FromUnit<$to, i128> for $from {
            fn to_base(value: i128) -> i128 {
                // Chain: $to -> $base -> $from
                let base_value =
                    <$base as $crate::unit::FromUnit<$to, i128>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, i128>>::to_base(base_value)
            }

            fn from_base(base_value: i128) -> i128 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, i128>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, i128>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for u8
#[macro_export]
macro_rules! convert_matrix_generate_pair_u8 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - u8 version)
        impl $crate::unit::FromUnit<$from, u8> for $to {
            fn to_base(value: u8) -> u8 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, u8>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, u8>>::to_base(base_value)
            }

            fn from_base(base_value: u8) -> u8 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, u8>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, u8>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - u8 version)
        impl $crate::unit::FromUnit<$to, u8> for $from {
            fn to_base(value: u8) -> u8 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, u8>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, u8>>::to_base(base_value)
            }

            fn from_base(base_value: u8) -> u8 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, u8>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, u8>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for u16
#[macro_export]
macro_rules! convert_matrix_generate_pair_u16 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - u16 version)
        impl $crate::unit::FromUnit<$from, u16> for $to {
            fn to_base(value: u16) -> u16 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, u16>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, u16>>::to_base(base_value)
            }

            fn from_base(base_value: u16) -> u16 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, u16>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, u16>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - u16 version)
        impl $crate::unit::FromUnit<$to, u16> for $from {
            fn to_base(value: u16) -> u16 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, u16>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, u16>>::to_base(base_value)
            }

            fn from_base(base_value: u16) -> u16 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, u16>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, u16>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for u32
#[macro_export]
macro_rules! convert_matrix_generate_pair_u32 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - u32 version)
        impl $crate::unit::FromUnit<$from, u32> for $to {
            fn to_base(value: u32) -> u32 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, u32>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, u32>>::to_base(base_value)
            }

            fn from_base(base_value: u32) -> u32 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, u32>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, u32>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - u32 version)
        impl $crate::unit::FromUnit<$to, u32> for $from {
            fn to_base(value: u32) -> u32 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, u32>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, u32>>::to_base(base_value)
            }

            fn from_base(base_value: u32) -> u32 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, u32>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, u32>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for u64
#[macro_export]
macro_rules! convert_matrix_generate_pair_u64 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - u64 version)
        impl $crate::unit::FromUnit<$from, u64> for $to {
            fn to_base(value: u64) -> u64 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, u64>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, u64>>::to_base(base_value)
            }

            fn from_base(base_value: u64) -> u64 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, u64>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, u64>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - u64 version)
        impl $crate::unit::FromUnit<$to, u64> for $from {
            fn to_base(value: u64) -> u64 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, u64>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, u64>>::to_base(base_value)
            }

            fn from_base(base_value: u64) -> u64 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, u64>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, u64>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for u128
#[macro_export]
macro_rules! convert_matrix_generate_pair_u128 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - u128 version)
        impl $crate::unit::FromUnit<$from, u128> for $to {
            fn to_base(value: u128) -> u128 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, u128>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, u128>>::to_base(base_value)
            }

            fn from_base(base_value: u128) -> u128 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, u128>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, u128>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - u128 version)
        impl $crate::unit::FromUnit<$to, u128> for $from {
            fn to_base(value: u128) -> u128 {
                // Chain: $to -> $base -> $from
                let base_value =
                    <$base as $crate::unit::FromUnit<$to, u128>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, u128>>::to_base(base_value)
            }

            fn from_base(base_value: u128) -> u128 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, u128>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, u128>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for f32
#[macro_export]
macro_rules! convert_matrix_generate_pair_f32 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - f32 version)
        impl $crate::unit::FromUnit<$from, f32> for $to {
            fn to_base(value: f32) -> f32 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, f32>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, f32>>::to_base(base_value)
            }

            fn from_base(base_value: f32) -> f32 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, f32>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, f32>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - f32 version)
        impl $crate::unit::FromUnit<$to, f32> for $from {
            fn to_base(value: f32) -> f32 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, f32>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, f32>>::to_base(base_value)
            }

            fn from_base(base_value: f32) -> f32 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, f32>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, f32>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for f64
#[macro_export]
macro_rules! convert_matrix_generate_pair_f64 {
    ($from:ty, $base:ty, $to:ty) => {
        // Generate $from -> $to via $base (transitive conversion - f64 generic version)
        impl $crate::unit::FromUnit<$from, f64> for $to {
            fn to_base(value: f64) -> f64 {
                // Chain: $from -> $base -> $to
                let base_value =
                    <$base as $crate::unit::FromUnit<$from, f64>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, f64>>::to_base(base_value)
            }

            fn from_base(base_value: f64) -> f64 {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, f64>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, f64>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion - f64 generic version)
        impl $crate::unit::FromUnit<$to, f64> for $from {
            fn to_base(value: f64) -> f64 {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, f64>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, f64>>::to_base(base_value)
            }

            fn from_base(base_value: f64) -> f64 {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, f64>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, f64>>::from_base(base_intermediate)
            }
        }
    };
}

/// Helper macro to generate all pairwise transitive conversions for i8
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i8 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i8!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i8!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i16
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i16 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i16!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i16!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i32
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i32 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i32!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i32!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i64
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i64 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i64!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i64!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i128
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i128 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i128!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i128!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u8
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u8 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u8!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u8!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u16
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u16 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u16!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u16!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u32
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u32 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u32!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u32!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u64
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u64 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u64!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u64!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u128
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u128 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u128!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u128!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for f32
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_f32 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_f32!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_f32!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for f64
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_f64 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_f64!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_f64!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Conversion matrix macro for signed integers - generates all possible unit conversions from a base unit
#[macro_export]
macro_rules! convert_matrix_signed {
    ($base:ty => $($target:ty),* $(,)?) => {
        // Generate all transitive conversions: Target1 â†” Target2 via Base
        $crate::convert_matrix_generate_all_pairs_i8!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i16!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i32!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i64!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i128!($base; $($target),*);
    };
}

/// Conversion matrix macro for unsigned integers - generates all possible unit conversions from a base unit
#[macro_export]
macro_rules! convert_matrix_unsigned {
    ($base:ty => $($target:ty),* $(,)?) => {
        // Generate all transitive conversions: Target1 â†” Target2 via Base
        $crate::convert_matrix_generate_all_pairs_u8!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u16!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u32!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u64!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u128!($base; $($target),*);
    };
}

/// Conversion matrix macro for floating-point types - generates all possible unit conversions from a base unit
#[macro_export]
macro_rules! convert_matrix_float {
    ($base:ty => $($target:ty),* $(,)?) => {
        // Generate all transitive conversions: Target1 â†” Target2 via Base
        $crate::convert_matrix_generate_all_pairs_f32!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_f64!($base; $($target),*);
    };
}

/// Conversion matrix macro - generates all possible unit conversions from a base unit
///
/// This macro takes a base unit and a list of target units, then automatically
/// generates all possible transitive conversions between every pair via the base unit.
/// You must define the direct base â†” target conversions using `convert!` first.
///
/// This is the top-level macro that calls the floating-point matrix generation.
///
/// # Syntax
/// ```ignore
/// use num_units::{units, convert, convert_matrix, convert_float};
///
/// // First define units
/// units! {
///     BaseUnit: "bu", "base unit";
///     TargetUnit1: "t1", "target unit 1";
///     TargetUnit2: "t2", "target unit 2";
///     TargetUnit3: "t3", "target unit 3";
/// }
///
/// // Then use the matrix
/// convert_matrix! {
///     BaseUnit => TargetUnit1, TargetUnit2, TargetUnit3
/// }
/// ```
///
/// # Requirements
/// Before using the matrix, you must define direct conversions using `convert!`:
/// ```ignore
/// use num_units::{units, convert, convert_float};
///
/// // Define units
/// units! {
///     BaseUnit: "bu", "base unit";
///     TargetUnit1: "t1", "target unit 1";
/// }
///
/// // Define conversions
/// convert! {
///     TargetUnit1: |base| base * 2.0;
///     BaseUnit: |target1| target1 / 2.0;
/// }
/// ```
///
/// # Generated Conversions
/// The matrix automatically generates transitive conversions:
/// - TargetUnit1 â†” TargetUnit2 (via BaseUnit)
/// - TargetUnit1 â†” TargetUnit3 (via BaseUnit)
/// - TargetUnit2 â†” TargetUnit3 (via BaseUnit)
///
/// This generates conversions for f32 and f64 types by default.
/// Use `convert_matrix_signed!`, `convert_matrix_unsigned!`, etc. for specific type sets.
///
/// # Example
/// ```ignore
/// use num_units::{units, convert, convert_matrix, convert_float};
/// use std::f64::consts::PI;
///
/// // First define units
/// units! {
///     Unitless: "", "unitless";
///     Revolution: "rev", "revolution";
///     Radian: "rad", "radian";
///     Degree: "deg", "degree";
/// }
///
/// // First define direct conversions
/// convert! {
///     Revolution: |unitless| unitless;
///     Unitless: |revolution| revolution;
/// }
/// convert! {
///     Radian: |unitless| unitless * 2.0 * PI;
///     Unitless: |radian| radian / (2.0 * PI);
/// }
///
/// // Then generate all transitive conversions
/// convert_matrix! {
///     Unitless => Revolution, Radian, Degree
/// }
/// ```
/// This generates Revolution â†” Radian, Revolution â†” Degree, Radian â†” Degree automatically!
#[macro_export]
macro_rules! convert_matrix {
    ($base:ty => $($target:ty),* $(,)?) => {
        $crate::convert_matrix_float! { $base => $($target),* }
    };
}
