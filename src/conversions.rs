/// # Unit Conversions - Advanced Conversion System
///
/// This module provides a comprehensive trait-based conversion system that works
/// for both base units and derived units, using the FromUnit/IntoUnit
/// approach as the foundation.
///
/// ## Overview
///
/// The conversion system enables seamless conversion between different units
/// within the same dimension. It uses trait-based conversions that are
/// automatically generated by the unit definition macros. The system uses a
/// macro-generating-macro pattern to reduce code duplication while maintaining
/// type-specific control.
///
/// ## Key Components
///
/// - **ConvertibleUnit Trait**: Extends Unit trait with conversion capabilities
/// - **FromUnit Trait**: Convert from any unit to its base unit
/// - **IntoUnit Trait**: Convert from base unit to any unit
/// - **Automatic Generation**: Conversion methods generated by macros
/// - **Shared Internal Macros**: `__impl_conversion!` and `__impl_matrix_pair!` reduce duplication
///
/// ## Macro Hierarchy
///
/// The conversion macros are organized in a hierarchical structure:
///
/// ### Top-Level Macros (User-facing)
/// - `convert!` - Main macro generating conversions for all numeric types
/// - `convert_linear!` - Simplified macro for linear conversions (y = ax + b)
/// - `convert_int!` - Integer conversions using factor syntax
/// - `convert_int_linear!` - Simplified macro for integer linear conversions
/// - `convert_matrix!` - Generate all transitive conversions from a base unit
///
/// ### Type-Group Macros (Middle layer)
/// - `convert_float!` - Generates f32 and f64 conversions
/// - `convert_signed!` - Generates all signed integer conversions (i8-i128)
/// - `convert_unsigned!` - Generates all unsigned integer conversions (u8-u128)
///
/// ### Individual Type Macros (Leaf macros)
/// - `convert_f32!`, `convert_f64!` - Floating-point implementations
/// - `convert_i8!` through `convert_i128!` - Signed integer implementations
/// - `convert_u8!` through `convert_u128!` - Unsigned integer implementations
///
/// ### Internal Shared Macros (Implementation)
/// - `__impl_conversion!` - Shared conversion implementation for all types
/// - `__impl_matrix_pair!` - Shared matrix pair generation
///
/// ## Conversion Type Hierarchy
///
/// ```text
/// convert! (main entry point - all numeric types)
///     â”œâ”€â”€ convert_float! â†’ {convert_f32!, convert_f64!} â†’ __impl_conversion!
///     â”œâ”€â”€ convert_signed! â†’ {convert_i8! ... convert_i128!} â†’ __impl_conversion!
///     â””â”€â”€ convert_unsigned! â†’ {convert_u8! ... convert_u128!} â†’ __impl_conversion!
///
/// convert_int! (integer conversions with factors)
///     â”œâ”€â”€ convert_signed! â†’ {convert_i8! ... convert_i128!}
///     â””â”€â”€ convert_unsigned! â†’ {convert_u8! ... convert_u128!}
///
/// convert_linear! (linear conversions - f32, f64 only)
///     â””â”€â”€ convert_float!
///
/// convert_matrix! (transitive conversions)
///     â””â”€â”€ convert_matrix_float!
///             â”œâ”€â”€ convert_matrix_generate_all_pairs_f32! â†’ __impl_matrix_pair!
///             â””â”€â”€ convert_matrix_generate_all_pairs_f64! â†’ __impl_matrix_pair!
/// ```
///
/// ## Usage Patterns
///
/// ### Basic Conversions
/// ```rust,ignore
/// use num_units::{convert, units};
///
/// // Define conversions for all numeric types (f32, f64, i8-i128, u8-u128)
/// convert! {
///     Kilometer: |meter| meter / 1000.0;
///     Meter: |kilometer| kilometer * 1000.0;
/// }
/// ```
///
/// ### Linear Conversions
/// ```rust,ignore
/// use num_units::convert_linear;
///
/// // Simple scaling: 1 km = 1000 m (generates f32, f64 only)
/// convert_linear! {
///     Kilometer => Meter: 1000.0;
/// }
///
/// // With offset: Â°C = K - 273.15
/// convert_linear! {
///     Celsius => Kelvin: 1.0, 273.15;
/// }
/// ```
///
/// ### Integer Conversions
/// ```rust,ignore
/// use num_units::convert_int;
///
/// // Integer factors converted to f64 expressions for all integer types
/// convert_int! {
///     Millimeter: 1000;  // 1 meter = 1000 millimeters
///     Meter: 1;          // 1 meter = 1 meter (base)
/// }
/// ```
///
/// ### Matrix Conversions
/// ```rust,ignore
/// use num_units::{convert, convert_matrix};
///
/// // Define base conversions first
/// convert! {
///     Radian: |unitless| unitless * 2.0 * PI;
///     Unitless: |radian| radian / (2.0 * PI);
/// }
///
/// // Generate all transitive conversions (f32, f64 only)
/// convert_matrix! {
///     Unitless => Revolution, Radian, Degree
/// }
/// // This generates: Revolution â†” Radian, Revolution â†” Degree, Radian â†” Degree
/// ```
///
/// ## Implementation Details
///
/// ### Conversion Flow
/// 1. User calls high-level macro (`convert!`, `convert_int!`, etc.)
/// 2. Macro delegates to type-group macros (`convert_float!`, `convert_signed!`, `convert_unsigned!`)
/// 3. Type-group macros delegate to individual type macros (`convert_f32!`, `convert_i8!`, etc.)
/// 4. Individual type macros use shared `__impl_conversion!` macro
/// 5. `__impl_conversion!` generates the actual `FromUnit` trait implementations
/// 6. Runtime conversions use these trait implementations
///
/// ### Type Support
/// - **Floating-point**: f32, f64 - Full precision, native f64 for f64, cast for f32
/// - **Small integers**: i8, i16, i32, u8, u16, u32 - Convert through f64 with rounding
/// - **Large integers**: i64, i128, u64, u128 - Direct integer expressions where possible
///
/// ### Precision Considerations
/// - All conversions use f64-based expressions at the top level
/// - f64 maintains full precision for floating-point operations
/// - Small integers (â‰¤32 bits) convert through f64 and round
/// - Large integers (â‰¥64 bits) can use direct integer math in expressions
/// - For exact integer conversions, use `convert_int!` with integer factors
///
/// ## Best Practices
///
/// 1. **Choose the right macro for your needs**:
///    - `convert!` - Standard conversions for all numeric types
///    - `convert_linear!` - Simple scaling/offset conversions
///    - `convert_int!` - Integer conversions with factor syntax
///    - `convert_int_linear!` - Simple integer scaling
///
/// 2. **Define a base unit for each dimension**:
///    - All other units convert to/from this base
///    - Use `convert_matrix!` to generate transitive conversions
///
/// 3. **Consider type coverage**:
///    - `convert!` generates conversions for all numeric types by default
///    - Integer conversions always go through f64 for consistency
///    - Use `convert_matrix!` for transitive conversions (f32, f64 only)
///
/// 4. **Organize conversions hierarchically**:
///    - Define base â†” derived conversions first
///    - Use matrix macro to generate derived â†” derived conversions
///    - Keep complex conversion logic in closures for maintainability

/// Trait for units that can be converted to/from base units
///
/// This trait extends the Unit trait with conversion capabilities
/// using the FromUnit/IntoUnit system.
pub trait ConvertibleUnit: crate::unit::Unit {
    /// The base unit for this unit's dimension
    type BaseUnit: crate::unit::Unit;

    /// Convert a value in this unit to its base unit
    fn to_base_unit<V>(value: V) -> V
    where
        V: num_traits::Num + Copy + From<f64> + num_traits::NumCast;

    /// Convert a value from this unit's base unit to this unit
    fn from_base_unit<V>(base_value: V) -> V
    where
        V: num_traits::Num + Copy + From<f64> + num_traits::NumCast;
}
/// Macro for establishing bidirectional conversion relationships between units
///
/// This macro creates conversion relationships between two units for all numeric types.
/// It uses floating-point expressions internally and automatically generates conversions
/// for f32, f64, i8-i128, and u8-u128.
///
/// # Syntax
/// ```rust,ignore
/// use num_units::convert;
///
/// convert! {
///     TargetUnit: |source_param| conversion_expression;
///     SourceUnit: |target_param| reverse_conversion_expression;
/// }
/// ```
///
/// # Examples
/// ```rust,ignore
/// use num_units::convert;
/// use num_units::prefix::KILO;
///
/// // Define conversion for all numeric types
/// convert! {
///     Kilometer: |meter| meter / KILO;      // km = m / 1000.0
///     Meter: |kilometer| kilometer * KILO;  // m = km * 1000.0
/// }
/// ```
///
/// This automatically generates conversions for all numeric types:
/// - Floating-point: f32, f64
/// - Signed integers: i8, i16, i32, i64, i128
/// - Unsigned integers: u8, u16, u32, u64, u128
#[macro_export]
macro_rules! convert {
    ($($input:tt)*) => {
        $crate::convert_float! { $($input)* }
        $crate::convert_signed! { $($input)* }
        $crate::convert_unsigned! { $($input)* }
    };
}

/// Macro for generating linear conversion relationships (y = ax + b)
///
/// This macro simplifies the creation of linear unit conversions by automatically
/// generating the forward and reverse conversion expressions. It supports both
/// simple scaling (y = ax) and offset conversions (y = ax + b).
///
/// # Syntax
/// ```rust,ignore
/// use num_units::convert_linear;
///
/// // Simple scaling (y = ax)
/// // DerivedUnit => BaseUnit: scale means 1 DerivedUnit = scale BaseUnits
/// convert_linear! {
///     DerivedUnit => BaseUnit: scale;
/// }
///
/// // With offset (y = ax + b)
/// // DerivedUnit => BaseUnit: scale, offset means DerivedUnit * scale + offset = BaseUnit
/// convert_linear! {
///     DerivedUnit => BaseUnit: scale, offset;
/// }
/// ```
///
/// # Generated Code
/// For `DerivedUnit => BaseUnit: a, b;`, this generates:
/// ```rust,ignore
/// convert! {
///     DerivedUnit: |base| (base - b) / a;  // DerivedUnit = (BaseUnit - offset) / scale
///     BaseUnit: |derived| derived * a + b; // BaseUnit = DerivedUnit * scale + offset
/// }
/// ```
///
/// # Examples
/// ```rust,ignore
/// use num_units::convert_linear;
/// use num_units::prefix::KILO;
///
/// // Simple scaling: 1 km = 1000 m (kilometer is derived, meter is base)
/// convert_linear! {
///     Kilometer => Meter: KILO;
/// }
/// // Generates:
/// // convert! {
/// //     Kilometer: |meter| meter / KILO;
/// //     Meter: |kilometer| kilometer * KILO;
/// // }
///
/// // With offset: Â°C + 273.15 = K (Celsius is derived, Kelvin is base)
/// convert_linear! {
///     Celsius => Kelvin: 1.0, 273.15;
/// }
/// // Generates:
/// // convert! {
/// //     Celsius: |kelvin| (kelvin - 273.15) / 1.0;
/// //     Kelvin: |celsius| celsius * 1.0 + 273.15;
/// // }
/// ```
#[macro_export]
macro_rules! convert_linear {
    // Pattern with both a and b (y = ax + b)
    // DerivedUnit => BaseUnit: scale, offset means:
    // DerivedUnit * scale + offset = BaseUnit
    // So: DerivedUnit = (BaseUnit - offset) / scale
    //     BaseUnit = DerivedUnit * scale + offset
    ($derived:ident => $base:ident: $a:expr, $b:expr;) => {
        $crate::convert_float! {
            $derived: |val| (val - ($b)) / ($a);
            $base: |val| val * ($a) + ($b);
        }
    };

    // Pattern with only a (y = ax)
    // DerivedUnit => BaseUnit: scale means 1 DerivedUnit = scale BaseUnits
    // E.g., Kilometer => Meter: 1000 means 1 km = 1000 m
    // So: DerivedUnit = BaseUnit / scale
    //     BaseUnit = DerivedUnit * scale
    ($derived:ident => $base:ident: $a:expr;) => {
        $crate::convert_float! {
            $derived: |val| val / ($a);
            $base: |val| val * ($a);
        }
    };

    // Multiple conversions
    ($($derived:ident => $base:ident: $($params:expr),+;)+) => {
        $(
            $crate::convert_linear! {
                $derived => $base: $($params),+;
            }
        )+
    };
}

/// Macro for generating integer linear conversion relationships
///
/// This is the integer version of `convert_linear!` which generates
/// `convert_int!` code for exact integer conversions. Use this when
/// both the scaling factor and offset (if any) are integers.
///
/// # Examples
/// ```rust,ignore
/// use num_units::convert_int_linear;
///
/// // Simple integer scaling: 1 km = 1000 m (kilometer is derived, meter is base)
/// convert_int_linear! {
///     Kilometer => Meter: 1000;
/// }
/// // Generates:
/// // convert_int! {
/// //     Kilometer: 1;
/// //     Meter: 1000;
/// // }
/// ```
#[macro_export]
macro_rules! convert_int_linear {
    // Pattern with only scaling factor (integers use numerator/denominator pattern)
    // DerivedUnit => BaseUnit: scale means DerivedUnit * 1 = BaseUnit * scale
    ($derived:ident => $base:ident: $scale:expr;) => {
        $crate::convert_int! {
            $derived: 1;
            $base: $scale;
        }
    };

    // Multiple conversions
    ($($derived:ident => $base:ident: $scale:expr;)+) => {
        $(
            $crate::convert_int_linear! {
                $derived => $base: $scale;
            }
        )+
    };
}

// ===== SHARED INTERNAL IMPLEMENTATION MACROS =====

/// Internal helper macro that contains the actual implementation pattern
/// This reduces duplication across all the type-specific macros
#[doc(hidden)]
#[macro_export]
macro_rules! __impl_conversion {
    // Pattern for integer types that convert through f64 with rounding
    (round: $type:ty, $unit1:ident, $param1:ident, $expr1:expr, $unit2:ident, $param2:ident, $expr2:expr) => {
        // Forward conversion: $unit2 -> $unit1
        impl $crate::unit::FromUnit<$unit2, $type> for $unit1 {
            fn to_base(value: $type) -> $type {
                let $param2 = value as f64;
                ($expr1).round() as $type
            }

            fn from_base(base_value: $type) -> $type {
                let $param1 = base_value as f64;
                ($expr2).round() as $type
            }
        }

        // Reverse conversion: $unit1 -> $unit2
        impl $crate::unit::FromUnit<$unit1, $type> for $unit2 {
            fn to_base(value: $type) -> $type {
                let $param1 = value as f64;
                ($expr2).round() as $type
            }

            fn from_base(base_value: $type) -> $type {
                let $param2 = base_value as f64;
                ($expr1).round() as $type
            }
        }
    };

    // Pattern for f32 (convert through f64 for expressions)
    (f32: $type:ty, $unit1:ident, $param1:ident, $expr1:expr, $unit2:ident, $param2:ident, $expr2:expr) => {
        // Forward conversion: $unit2 -> $unit1
        impl $crate::unit::FromUnit<$unit2, $type> for $unit1 {
            fn to_base(value: $type) -> $type {
                let $param2 = value as f64;
                ($expr1) as $type
            }

            fn from_base(base_value: $type) -> $type {
                let $param1 = base_value as f64;
                ($expr2) as $type
            }
        }

        // Reverse conversion: $unit1 -> $unit2
        impl $crate::unit::FromUnit<$unit1, $type> for $unit2 {
            fn to_base(value: $type) -> $type {
                let $param1 = value as f64;
                ($expr2) as $type
            }

            fn from_base(base_value: $type) -> $type {
                let $param2 = base_value as f64;
                ($expr1) as $type
            }
        }
    };

    // Pattern for f64 (native precision)
    (f64: $type:ty, $unit1:ident, $param1:ident, $expr1:expr, $unit2:ident, $param2:ident, $expr2:expr) => {
        // Forward conversion: $unit2 -> $unit1
        impl $crate::unit::FromUnit<$unit2, $type> for $unit1 {
            fn to_base(value: $type) -> $type {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: $type) -> $type {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2
        impl $crate::unit::FromUnit<$unit1, $type> for $unit2 {
            fn to_base(value: $type) -> $type {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: $type) -> $type {
                let $param2 = base_value;
                $expr1
            }
        }
    };

    // Pattern for large integers (i64, i128, u64, u128) that can use direct expressions
    (direct: $type:ty, $unit1:ident, $param1:ident, $expr1:expr, $unit2:ident, $param2:ident, $expr2:expr) => {
        // Forward conversion: $unit2 -> $unit1
        impl $crate::unit::FromUnit<$unit2, $type> for $unit1 {
            fn to_base(value: $type) -> $type {
                let $param2 = value;
                $expr1
            }

            fn from_base(base_value: $type) -> $type {
                let $param1 = base_value;
                $expr2
            }
        }

        // Reverse conversion: $unit1 -> $unit2
        impl $crate::unit::FromUnit<$unit1, $type> for $unit2 {
            fn to_base(value: $type) -> $type {
                let $param1 = value;
                $expr2
            }

            fn from_base(base_value: $type) -> $type {
                let $param2 = base_value;
                $expr1
            }
        }
    };
}

// ===== HIERARCHICAL CONVERSION MACROS =====

/// Macro for specific integer type conversions (i8)
#[macro_export]
macro_rules! convert_i8 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(round: i8, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_i8! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i16)
#[macro_export]
macro_rules! convert_i16 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(round: i16, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_i16! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i32)
#[macro_export]
macro_rules! convert_i32 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(round: i32, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_i32! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i64)
#[macro_export]
macro_rules! convert_i64 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(direct: i64, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_i64! { $($rest)* }
    };
    () => {};
}

/// Macro for specific integer type conversions (i128)
#[macro_export]
macro_rules! convert_i128 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(direct: i128, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_i128! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u8)
#[macro_export]
macro_rules! convert_u8 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(round: u8, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_u8! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u16)
#[macro_export]
macro_rules! convert_u16 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(round: u16, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_u16! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u32)
#[macro_export]
macro_rules! convert_u32 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(round: u32, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_u32! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u64)
#[macro_export]
macro_rules! convert_u64 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(direct: u64, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_u64! { $($rest)* }
    };
    () => {};
}

/// Macro for unsigned integer type conversions (u128)
#[macro_export]
macro_rules! convert_u128 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(direct: u128, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_u128! { $($rest)* }
    };
    () => {};
}

/// Macro for floating-point type conversions (f32)
#[macro_export]
macro_rules! convert_f32 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(f32: f32, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_f32! { $($rest)* }
    };
    () => {};
}

/// Macro for floating-point type conversions (f64)
#[macro_export]
macro_rules! convert_f64 {
    ($unit1:ident: |$param1:ident| $expr1:expr; $unit2:ident: |$param2:ident| $expr2:expr; $($rest:tt)*) => {
        $crate::__impl_conversion!(f64: f64, $unit1, $param1, $expr1, $unit2, $param2, $expr2);
        convert_f64! { $($rest)* }
    };
    () => {};
}

/// Macro for all signed integer type conversions
#[macro_export]
macro_rules! convert_signed {
    ($($input:tt)*) => {
        $crate::convert_i8! { $($input)* }
        $crate::convert_i16! { $($input)* }
        $crate::convert_i32! { $($input)* }
        $crate::convert_i64! { $($input)* }
        $crate::convert_i128! { $($input)* }
    };
}

/// Macro for all unsigned integer type conversions
#[macro_export]
macro_rules! convert_unsigned {
    ($($input:tt)*) => {
        $crate::convert_u8! { $($input)* }
        $crate::convert_u16! { $($input)* }
        $crate::convert_u32! { $($input)* }
        $crate::convert_u64! { $($input)* }
        $crate::convert_u128! { $($input)* }
    };
}

/// Macro for all floating-point type conversions
#[macro_export]
macro_rules! convert_float {
    ($($input:tt)*) => {
        $crate::convert_f32! { $($input)* }
        $crate::convert_f64! { $($input)* }
    };
}

/// Macro for establishing bidirectional conversion relationships between units (all integer types)
///
/// This macro creates conversion relationships for all integer types (signed and unsigned).
/// It converts the integer factor syntax into f64-based closures and delegates to
/// convert_signed! and convert_unsigned!.
///
/// # Syntax
/// ```rust,ignore
/// use num_units::convert_int;
///
/// // Define conversions using integer factors
/// convert_int! {
///     TargetUnit: 1;    // 1 base = 1 target
///     SourceUnit: 10;   // 1 base = 10 source
/// }
/// ```
///
/// # Examples
/// ```rust,ignore
/// use num_units::convert_int;
///
/// // Define conversion with exact integer factors
/// convert_int! {
///     Millimeter: 1000;  // 1 meter = 1000 millimeters
///     Meter: 1;          // 1 meter = 1 meter (base unit)
/// }
/// ```
///
/// This delegates to convert_signed! and convert_unsigned! which generate
/// implementations for all integer types using the shared __impl_conversion! macro.
#[macro_export]
macro_rules! convert_int {
    // Process pairs of units with integer conversion factors
    ($unit1:ident: $factor1:expr; $unit2:ident: $factor2:expr; $($rest:tt)*) => {
        // Convert integer factors to f64-based closures and delegate to signed/unsigned macros
        $crate::convert_signed! {
            $unit1: |val| val * ($factor2 as f64) / ($factor1 as f64);
            $unit2: |val| val * ($factor1 as f64) / ($factor2 as f64);
        }

        $crate::convert_unsigned! {
            $unit1: |val| val * ($factor2 as f64) / ($factor1 as f64);
            $unit2: |val| val * ($factor1 as f64) / ($factor2 as f64);
        }

        // Process remaining conversions recursively
        convert_int! { $($rest)* }
    };

    // Base case: no more conversions to process
    () => {};
}

// ðŸŽ©âœ¨ CONVERSION MATRIX MAGIC âœ¨ðŸŽ©
// Define conversions from one base unit to all others, then generate all combinations!

/// Internal helper for matrix pair generation
/// This reduces duplication across all the type-specific matrix pair generators
#[doc(hidden)]
#[macro_export]
macro_rules! __impl_matrix_pair {
    ($from:ty, $base:ty, $to:ty, $type:ty) => {
        // Generate $from -> $to via $base (transitive conversion)
        impl $crate::unit::FromUnit<$from, $type> for $to {
            fn to_base(value: $type) -> $type {
                // Chain: $from -> $base -> $to
                let base_value = <$base as $crate::unit::FromUnit<$from, $type>>::to_base(value);
                <$to as $crate::unit::FromUnit<$base, $type>>::to_base(base_value)
            }

            fn from_base(base_value: $type) -> $type {
                // Chain: $to -> $base -> $from
                let base_intermediate =
                    <$to as $crate::unit::FromUnit<$base, $type>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$from, $type>>::from_base(base_intermediate)
            }
        }

        // Generate $to -> $from via $base (reverse transitive conversion)
        impl $crate::unit::FromUnit<$to, $type> for $from {
            fn to_base(value: $type) -> $type {
                // Chain: $to -> $base -> $from
                let base_value = <$base as $crate::unit::FromUnit<$to, $type>>::to_base(value);
                <$from as $crate::unit::FromUnit<$base, $type>>::to_base(base_value)
            }

            fn from_base(base_value: $type) -> $type {
                // Chain: $from -> $base -> $to
                let base_intermediate =
                    <$from as $crate::unit::FromUnit<$base, $type>>::from_base(base_value);
                <$base as $crate::unit::FromUnit<$to, $type>>::from_base(base_intermediate)
            }
        }
    };
}

/// Generate a single bidirectional transitive conversion pair for i8
#[macro_export]
macro_rules! convert_matrix_generate_pair_i8 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, i8);
    };
}

/// Generate a single bidirectional transitive conversion pair for i16
#[macro_export]
macro_rules! convert_matrix_generate_pair_i16 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, i16);
    };
}

/// Generate a single bidirectional transitive conversion pair for i32
#[macro_export]
macro_rules! convert_matrix_generate_pair_i32 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, i32);
    };
}

/// Generate a single bidirectional transitive conversion pair for i64
#[macro_export]
macro_rules! convert_matrix_generate_pair_i64 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, i64);
    };
}

/// Generate a single bidirectional transitive conversion pair for i128
#[macro_export]
macro_rules! convert_matrix_generate_pair_i128 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, i128);
    };
}

/// Generate a single bidirectional transitive conversion pair for u8
#[macro_export]
macro_rules! convert_matrix_generate_pair_u8 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, u8);
    };
}

/// Generate a single bidirectional transitive conversion pair for u16
#[macro_export]
macro_rules! convert_matrix_generate_pair_u16 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, u16);
    };
}

/// Generate a single bidirectional transitive conversion pair for u32
#[macro_export]
macro_rules! convert_matrix_generate_pair_u32 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, u32);
    };
}

/// Generate a single bidirectional transitive conversion pair for u64
#[macro_export]
macro_rules! convert_matrix_generate_pair_u64 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, u64);
    };
}

/// Generate a single bidirectional transitive conversion pair for u128
#[macro_export]
macro_rules! convert_matrix_generate_pair_u128 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, u128);
    };
}

/// Generate a single bidirectional transitive conversion pair for f32
#[macro_export]
macro_rules! convert_matrix_generate_pair_f32 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, f32);
    };
}

/// Generate a single bidirectional transitive conversion pair for f64
#[macro_export]
macro_rules! convert_matrix_generate_pair_f64 {
    ($from:ty, $base:ty, $to:ty) => {
        $crate::__impl_matrix_pair!($from, $base, $to, f64);
    };
}

/// Helper macro to generate all pairwise transitive conversions for i8
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i8 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i8!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i8!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i16
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i16 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i16!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i16!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i32
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i32 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i32!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i32!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i64
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i64 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i64!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i64!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for i128
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_i128 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_i128!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_i128!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u8
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u8 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u8!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u8!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u16
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u16 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u16!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u16!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u32
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u32 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u32!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u32!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u64
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u64 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u64!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u64!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for u128
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_u128 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_u128!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_u128!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for f32
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_f32 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_f32!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_f32!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Helper macro to generate all pairwise transitive conversions for f64
#[macro_export]
macro_rules! convert_matrix_generate_all_pairs_f64 {
    ($base:ty; $first:ty $(, $rest:ty)*) => {
        // Generate conversions from $first to all remaining targets
        $(
            $crate::convert_matrix_generate_pair_f64!($first, $base, $rest);
        )*

        // Recursively process remaining targets (but don't include $first again)
        $crate::convert_matrix_generate_all_pairs_f64!($base; $($rest),*);
    };

    // Base case: only one or no targets left
    ($base:ty; $single:ty) => {};
    ($base:ty;) => {};
}

/// Conversion matrix macro for signed integers - generates all possible unit conversions from a base unit
#[macro_export]
macro_rules! convert_matrix_signed {
    ($base:ty => $($target:ty),* $(,)?) => {
        // Generate all transitive conversions: Target1 â†” Target2 via Base
        $crate::convert_matrix_generate_all_pairs_i8!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i16!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i32!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i64!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_i128!($base; $($target),*);
    };
}

/// Conversion matrix macro for unsigned integers - generates all possible unit conversions from a base unit
#[macro_export]
macro_rules! convert_matrix_unsigned {
    ($base:ty => $($target:ty),* $(,)?) => {
        // Generate all transitive conversions: Target1 â†” Target2 via Base
        $crate::convert_matrix_generate_all_pairs_u8!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u16!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u32!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u64!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_u128!($base; $($target),*);
    };
}

/// Conversion matrix macro for floating-point types - generates all possible unit conversions from a base unit
#[macro_export]
macro_rules! convert_matrix_float {
    ($base:ty => $($target:ty),* $(,)?) => {
        // Generate all transitive conversions: Target1 â†” Target2 via Base
        $crate::convert_matrix_generate_all_pairs_f32!($base; $($target),*);
        $crate::convert_matrix_generate_all_pairs_f64!($base; $($target),*);
    };
}

/// Conversion matrix macro - generates all possible unit conversions from a base unit
///
/// This macro takes a base unit and a list of target units, then automatically
/// generates all possible transitive conversions between every pair via the base unit.
/// You must define the direct base â†” target conversions using `convert!` first.
///
/// This is the top-level macro that calls the floating-point matrix generation.
///
/// # Syntax
/// ```rust,ignore
/// use num_units::{units, convert, convert_matrix, convert_float};
///
/// // First define units
/// units! {
///     BaseUnit: "bu", "base unit";
///     TargetUnit1: "t1", "target unit 1";
///     TargetUnit2: "t2", "target unit 2";
///     TargetUnit3: "t3", "target unit 3";
/// }
///
/// // Then use the matrix
/// convert_matrix! {
///     BaseUnit => TargetUnit1, TargetUnit2, TargetUnit3
/// }
/// ```
///
/// # Requirements
/// Before using the matrix, you must define direct conversions using `convert!`:
/// ```rust,ignore
/// use num_units::{units, convert, convert_float};
///
/// // Define units
/// units! {
///     BaseUnit: "bu", "base unit";
///     TargetUnit1: "t1", "target unit 1";
/// }
///
/// // Define conversions
/// convert! {
///     TargetUnit1: |base| base * 2.0;
///     BaseUnit: |target1| target1 / 2.0;
/// }
/// ```
///
/// # Generated Conversions
/// The matrix automatically generates transitive conversions:
/// - TargetUnit1 â†” TargetUnit2 (via BaseUnit)
/// - TargetUnit1 â†” TargetUnit3 (via BaseUnit)
/// - TargetUnit2 â†” TargetUnit3 (via BaseUnit)
///
/// This generates conversions for f32 and f64 types by default.
/// Use `convert_matrix_signed!`, `convert_matrix_unsigned!`, etc. for specific type sets.
///
/// # Example
/// ```rust,ignore
/// use num_units::{units, convert, convert_matrix, convert_float};
/// use std::f64::consts::PI;
///
/// // First define units
/// units! {
///     Unitless: "", "unitless";
///     Revolution: "rev", "revolution";
///     Radian: "rad", "radian";
///     Degree: "deg", "degree";
/// }
///
/// // First define direct conversions
/// convert! {
///     Revolution: |unitless| unitless;
///     Unitless: |revolution| revolution;
/// }
/// convert! {
///     Radian: |unitless| unitless * 2.0 * PI;
///     Unitless: |radian| radian / (2.0 * PI);
/// }
///
/// // Then generate all transitive conversions
/// convert_matrix! {
///     Unitless => Revolution, Radian, Degree
/// }
/// ```
/// This generates Revolution â†” Radian, Revolution â†” Degree, Radian â†” Degree automatically!
#[macro_export]
macro_rules! convert_matrix {
    ($base:ty => $($target:ty),* $(,)?) => {
        // $crate::convert_matrix_float! { $base => $($target),* }
    };
}
