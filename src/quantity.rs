use core::ops::{Add, Div, Mul, Neg, Sub};
use num_traits::{Num, Zero};

/// A physical quantity with a numerical value and dimensional analysis
///
/// This struct combines a numerical value (implementing num-traits::Num) with
/// compile-time dimensional analysis to ensure physical correctness.
///
/// # Type Parameters
/// - `T`: The numerical type (must implement `num-traits::Num`)
/// - `D`: The dimension type (generated by the `dimension!` macro)
///
/// # Examples
/// ```rust
/// # #![feature(generic_const_exprs)]
/// # use nom::quantity::Quantity;
/// # use nom_macros::dimension;
/// # #[dimension(L, M, T)] pub struct Physics;
/// # type LengthDimension = Physics<1, 0, 0>;
///
/// let length = Quantity::<f64, LengthDimension>::new(5.0);
/// let width = Quantity::<f64, LengthDimension>::new(3.0);
/// let total_length = length + width; // Same dimensions - addition works
/// ```
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Quantity<V, D> {
    pub value: V,
    _dimension: core::marker::PhantomData<D>,
}

impl<V, D> Quantity<V, D>
where
    V: Num,
{
    /// Create a new quantity with the given value
    pub const fn new(value: V) -> Self {
        Self {
            value,
            _dimension: core::marker::PhantomData,
        }
    }

    /// Get the numerical value of this quantity
    pub fn base(&self) -> &V {
        &self.value
    }

    /// Get the numerical value of this quantity (consuming)
    pub fn into_base(self) -> V {
        self.value
    }

    /// Create a quantity from a raw value (same as `new` but more explicit)
    pub const fn from_base(value: V) -> Self {
        Self::new(value)
    }

    /// Get the absolute value of this quantity
    pub fn abs(self) -> Self
    where
        V: num_traits::Signed,
    {
        Quantity::new(self.value.abs())
    }
}

// Unit-aware methods for f64 quantities
impl<D> Quantity<f64, D> {
    // Unit-specific methods are now generated by the unit! macro
}

// Addition: Only allowed for quantities with the same dimension
impl<V, D> Add for Quantity<V, D>
where
    V: Num + Add<Output = V>,
{
    type Output = Quantity<V, D>;

    fn add(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value + rhs.value)
    }
}

// Subtraction: Only allowed for quantities with the same dimension
impl<V, D> Sub for Quantity<V, D>
where
    V: Num + Sub<Output = V>,
{
    type Output = Quantity<V, D>;

    fn sub(self, rhs: Self) -> Self::Output {
        Quantity::new(self.value - rhs.value)
    }
}

// Negation
impl<V, D> Neg for Quantity<V, D>
where
    V: Num + Neg<Output = V>,
{
    type Output = Quantity<V, D>;

    fn neg(self) -> Self::Output {
        Quantity::new(-self.value)
    }
}

// Multiplication: Multiplies values and adds dimensions (D1 + D2)
impl<V, D1, D2> Mul<Quantity<V, D2>> for Quantity<V, D1>
where
    V: Num + Mul<Output = V>,
    D1: Add<D2>,
{
    type Output = Quantity<V, <D1 as Add<D2>>::Output>;

    fn mul(self, rhs: Quantity<V, D2>) -> Self::Output {
        Quantity::new(self.value * rhs.value)
    }
}

// Division: Divides values and subtracts dimensions (D1 - D2)
impl<V, D1, D2> Div<Quantity<V, D2>> for Quantity<V, D1>
where
    V: Num + Div<Output = V>,
    D1: Sub<D2>,
{
    type Output = Quantity<V, <D1 as Sub<D2>>::Output>;

    fn div(self, rhs: Quantity<V, D2>) -> Self::Output {
        Quantity::new(self.value / rhs.value)
    }
}

// Scalar multiplication (quantity * scalar)
impl<V, D> Mul<V> for Quantity<V, D>
where
    V: Num + Mul<Output = V> + Copy,
{
    type Output = Quantity<V, D>;

    fn mul(self, scalar: V) -> Self::Output {
        Quantity::new(self.value * scalar)
    }
}

// Scalar division (quantity / scalar)
impl<V, D> Div<V> for Quantity<V, D>
where
    V: Num + Div<Output = V> + Copy,
{
    type Output = Quantity<V, D>;

    fn div(self, scalar: V) -> Self::Output {
        Quantity::new(self.value / scalar)
    }
}

// num-traits support for Zero
impl<V, D> Zero for Quantity<V, D>
where
    V: Num + Zero,
{
    fn zero() -> Self {
        Quantity::new(V::zero())
    }

    fn is_zero(&self) -> bool {
        self.value.is_zero()
    }
}

// Display implementation
impl<V, D> core::fmt::Display for Quantity<V, D>
where
    V: core::fmt::Display,
    D: core::fmt::Display + Default,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{} [{}]", self.value, D::default())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dimension;
    use num_traits::Zero;

    // Use the dimension! macro to create TestPhysics
    dimension!(TestPhysics, L, M, T);

    type TestLength = TestPhysics<1, 0, 0>;
    type TestMass = TestPhysics<0, 1, 0>;

    #[test]
    fn test_quantity_creation() {
        let length = Quantity::<f64, TestLength>::new(5.0);
        assert_eq!(*length.base(), 5.0);

        let mass = Quantity::<i32, TestMass>::new(10);
        assert_eq!(*mass.base(), 10);
    }

    #[test]
    fn test_same_dimension_operations() {
        let length1 = Quantity::<f64, TestLength>::new(5.0);
        let length2 = Quantity::<f64, TestLength>::new(3.0);

        let sum = length1 + length2;
        assert_eq!(*sum.base(), 8.0);

        let diff = length1 - length2;
        assert_eq!(*diff.base(), 2.0);
    }

    #[test]
    fn test_scalar_operations() {
        let length = Quantity::<f64, TestLength>::new(5.0);

        let doubled = length * 2.0;
        assert_eq!(*doubled.base(), 10.0);

        let halved = length / 2.0;
        assert_eq!(*halved.base(), 2.5);
    }

    #[test]
    fn test_zero_and_negation() {
        let zero_length = Quantity::<f64, TestLength>::zero();
        assert!(zero_length.is_zero());
        assert_eq!(*zero_length.base(), 0.0);

        let length = Quantity::<f64, TestLength>::new(5.0);
        let neg_length = -length;
        assert_eq!(*neg_length.base(), -5.0);
    }

    #[test]
    fn test_absolute_value() {
        let negative_length = Quantity::<f64, TestLength>::new(-5.0);
        let abs_length = negative_length.abs();
        assert_eq!(*abs_length.base(), 5.0);
    }

    #[test]
    fn test_display() {
        let length = Quantity::<f64, TestLength>::new(3.14159);
        // Test that the display trait is implemented
        // In no_std, we can't easily test format! but we can verify the trait exists
        let _: &dyn core::fmt::Display = &length;
    }

    #[test]
    fn test_dimensional_multiplication() {
        // Test that multiplication properly adds dimensions
        let length1 = Quantity::<f64, TestLength>::new(5.0);
        let length2 = Quantity::<f64, TestLength>::new(3.0);

        // Length × Length should give us a quantity with dimension L²M⁰T⁰
        let area = length1 * length2;
        assert_eq!(*area.base(), 15.0);

        // The type should be Quantity<f64, TestPhysics<2, 0, 0>>
        // We can't directly test the type, but if it compiles, the dimensions worked
    }

    #[test]
    fn test_dimensional_division() {
        // Test that division properly subtracts dimensions
        let length = Quantity::<f64, TestLength>::new(10.0);
        let time = Quantity::<f64, TestPhysics<0, 0, 1>>::new(2.0);

        // Length ÷ Time should give us velocity with dimension L¹M⁰T⁻¹
        let velocity = length / time;
        assert_eq!(*velocity.base(), 5.0);

        // Again, if this compiles, the dimensional math worked correctly
    }

    #[test]
    fn test_unit_system_integration() {
        use crate::si::length::LengthDimension;

        // Test unit construction using new unit-specific methods
        let one_meter = Quantity::<f64, LengthDimension>::from_meters(1.0);
        let hundred_cm = Quantity::<f64, LengthDimension>::from_centimeters(100.0);

        // Both should be equal in base units
        assert!((one_meter.into_base() - hundred_cm.into_base()).abs() < 1e-10);

        // Test unit extraction using new unit-specific methods
        let meters_value = one_meter.as_meters();
        let feet_value = one_meter.as_feet(); // Now properly using "feet" method
        let cm_value = one_meter.as_centimeters();

        assert!((meters_value - 1.0).abs() < 1e-10);
        assert!((feet_value - 3.28084).abs() < 0.001);
        assert!((cm_value - 100.0).abs() < 1e-10);

        // Test unit arithmetic
        let two_meters = Quantity::<f64, LengthDimension>::from_meters(2.0);
        let six_feet = Quantity::<f64, LengthDimension>::from_feet(6.0); // Now properly using "feet" method
        let total = two_meters + six_feet;

        // 2m + 6ft = 2 + 1.8288 = 3.8288m
        let total_meters = total.as_meters();
        assert!((total_meters - 3.8288).abs() < 0.001);
    }

    #[test]
    fn test_length_multiplication_creates_area() {
        use crate::si::SI;
        use crate::si::length::LengthDimension;

        // Define area type: Length² = SI<2, 0, 0, 0, 0, 0, 0>
        type AreaDimension = SI<2, 0, 0, 0, 0, 0, 0>;

        // Create two length quantities
        let width = Quantity::<f64, LengthDimension>::from_meters(3.0);
        let height = Quantity::<f64, LengthDimension>::from_meters(4.0);

        // Multiply them to get area
        let area: Quantity<f64, AreaDimension> = width * height;

        // The result should be 12 square meters (in base units, which are square meters)
        assert!((area.into_base() - 12.0).abs() < 1e-10);

        // Test with different units
        let width_ft = Quantity::<f64, LengthDimension>::from_feet(10.0); // 10 ft = 3.048 m
        let height_m = Quantity::<f64, LengthDimension>::from_meters(2.0); // 2 m
        let mixed_area: Quantity<f64, AreaDimension> = width_ft * height_m;

        // Expected: 3.048 * 2.0 = 6.096 square meters
        assert!((mixed_area.into_base() - 6.096).abs() < 0.001);
    }
}
